:: n1s Guess Script [mt-ready inclusion] {"position":"4250,950","size":"100,100"}
<<script>>
const V = State.variables;
const T = State.temporary;

V.n_passTried || (V.n_passTried = []);
V.n_passFound || (V.n_passFound = []);

T.sayPassword = "[[n1s Say Password]]".slice(2, -2);

let onceSeen = {};
const once = (phrase1, phrase2) => {
  if (onceSeen[phrase1]) {
    return phrase2;
  } else {
    onceSeen[phrase1] = true;
    return phrase1;
  }
};
const another = phrase => {
  const m = /^(the|a|an) (.*)/.exec(phrase);
  if (m == null) {
    return phrase;
  } else {
    return once(phrase, `another ${m[2]}`);
  }
};

T.describe = pw => {
  if (/^Please-/i.test(pw)) {
    return `"${pw}" (${another("a mistake")})`;
  } else if (/^#/.test(pw)) {
    return `"${pw.slice(1)}" (${another("a mistake")})`;
  } else if (MT.basicPasswords[pw] != null) {
    return `"${pw}" (${another(MT.basicPasswords[pw])})`;
  } else if (MT.otherPasswords[pw] != null) {
    return `"${pw}" (${another(MT.otherPasswords[pw])})`;
  } else {
    return `"${pw}" (BUG: no source)`;
  }
};

T.listFailed = () => {
  // note, reverse order
  const tried = V.n_passTried || [];
  const desc = i => T.describe(tried[i]);
  if (tried.length === 1) {
    return `${desc(0)}.`;
  } else if (tried.length === 2) {
    return `${desc(1)} and ${desc(0)}.`;
  } else {
    let buf = "";
    for (let i = tried.length - 1; i > 0; i--) {
      buf += `${desc(i)}, `;
    }
    buf += `and ${desc(0)}.`;
    return buf;
  }
};

T.toTry = [];
T.hasBasics = false;
for (const pw of Object.keys(MT.basicPasswords)) {
  if (!V.n_passTried.includes(pw)) {
    T.toTry.push(pw);
    T.hasBasics = true;
  }
}
for (const pw of V.n_passFound) {
  if (pw === PW_hunter && V.n_passTried.includes(PW_too)) continue;
  if (!V.n_passTried.includes(pw)) {
    T.toTry.push(pw);
  }
}
if (T.toTry.length === 0) {
  throw new Error(`bug: ran out of passwords to try?`);
}
T.toTry.sort();
<</script>>\
