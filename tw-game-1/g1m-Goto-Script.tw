:: g1m Goto Script [inclusion] {"position":"200,2000","size":"100,100"}
<<script>>

State.temporary.listWalks = () => {
  const walks = MT.walks;
  const current = MT.getPath();
  let mkp = "<<nobr>>";
  for (let i = 0; i < walks.length; i++) {
    if (typeof walks[i] === "string") {
      mkp += `<div class="walk-header">${walks[i]}</div>`;
      continue;
    }

    const addSeg = (ch, type, opts) => {
      const note = opts.note ? " walk-choice-note" : "";
      if (opts.width != null) {
        mkp += `<span class=walk-sp>`;
        mkp += `<span class="walk-sp-w${note}">> ${opts.width}</span>`;
      }
      mkp += `<span class="walk-choice walk-choice-${type}${note}">`;
      mkp += `<<link "> ${ch}">>`;
      mkp += `<<run _doWalk(${i}, "${ch}")>>`;
      mkp += `<</link>>`;
      if (opts.width != null) mkp += `</span>`;
      mkp += `</span> `;
    };

    const path = walks[i].path;
    const [pn, cn] = MT.commonPathLengths(path, current);

    mkp += `<div class=walk-path>`;
    if (pn === path.length) {
      /* all of path is in the past of current */
      for (const st of path) {
        if (st.choice != null) addSeg(st.choice, "past", st);
      }
    } else if (cn === current.length) {
      /* all of current is on path */
      let ppn = pn;
      /* sometimes choice marker is an empty segment. */
      if (ppn !== 0 && path[ppn].choice != null) {
        while (ppn < path.length - 1 && path[ppn].choice != null) ppn++;
      }
      /* find finished choice in path */
      while (ppn > 1 && path[ppn].choice == null) ppn--;
      for (const st of path.slice(0, ppn)) {
        if (st.choice != null) addSeg(st.choice, "past", st);
      }
      for (const st of path.slice(ppn)) {
        if (st.choice != null) addSeg(st.choice, "future", st);
      }
    } else {
      /* path and current are disjoint */
      for (const st of path) {
        if (st.choice != null) addSeg(st.choice, "disjoint", st);
      }
    }
    const len = path.filter(st => st.t != null).length;
    mkp += `<span class=walk-path-len>[${len}]</span>`;
    mkp += `</div>`;
  }
  mkp += "<</nobr>>";
  return mkp;
};

function getPathChoice(path, ch) {
  const result = [];
  let seen = false;
  for (const step of path) {
    if (step.choice != null && seen) break;
    result.push(step);
    if (step.choice != null) seen = step.choice === ch;
  }
  return result;
}

function setVars(vars) {
  if (vars != null) {
    for (const vn of Object.keys(vars)) {
      State.variables[vn] = vars[vn];
    }
  }
}

function setMeta(meta) {
  if (meta != null) {
    for (const vn of Object.keys(meta)) {
      MT.mdSet(vn, meta[vn]);
    }
  }
}

State.temporary.doWalk = (i, ch) => {
  MT.forgetWalkHistory();
  const walk = MT.walks[i];
  const force = !!$("#walk-force").prop("checked");
  const path = getPathChoice(walk.path, ch);
  State.reset();
  Engine.play("g1a Bound");
  setMeta(walk.meta);
  setVars(walk.vars);
  MT.roamStart(path, null, force);
};

State.temporary.reWalk = () => {
  const path = MT.getPath();
  const force = !!$("#walk-force").prop("checked");
  MT.forgetWalkHistory();
  State.reset();
  Engine.play("g1a Bound");
  MT.roamStart(path, null, force);
};

State.temporary.showCurrentPath = () => {
  const path = MT.getPath();
  const js = MT.pathToJs(path);
  $("#walk-current-path").val(`// current path [${path.length}]\n${js}`);
};

State.temporary.walkAll = () => {
  const walks = MT.walks;
  const force = !!$("#walk-force").prop("checked");
  let i = 0;
  const t0 = Date.now();
  const startNext = () => {
    const t1 = Date.now();
    while (i < walks.length && walks[i].path == null) i++;
    if (i >= walks.length) {
      const dt = Date.now() - t0;
      console.log(`done walkAll in ${dt / 1000}s`);
      return;
    }
    const walk = walks[i++];
    console.log(`Starting ${MT.pathName(walk.path)}`);
    MT.forgetWalkHistory();
    State.reset();
    Engine.play("g1a Bound");
    setMeta(walk.meta);
    setVars(walk.vars);
    const done = () => {
      const dt = Date.now() - t1;
      console.log(`done path in ${dt / 1000}s`);
      startNext();
    };
    MT.roamStart(walk.path, done, force);
  };
  startNext();
}

$(document).one(":passagedisplay", () => {
  const force = session.get("walk-force");
  const el = $("#walk-force");
  el.prop("checked", force);
  el.on("input", () => {
    session.set("walk-force", !!el.prop("checked"))
  })
});

<</script>>\
