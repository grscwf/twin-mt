:: Init 2 Random Walk [inclusion] {"position":"2850,600","size":"100,100"}
<<append head>><style>
  #random-walk {
    top: max(5rem, 50vh - 5rem);
    display: flex;
    flex-direction: column;
    font-size: 18px;
    gap: 20px;
    position: fixed;
    right: 4px;
    z-index: 20;
  }

  #random-walk a {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 4px;
    color: #000;
    cursor: pointer;
    opacity: 0.1;
    padding: 2px 4px;
    text-align: center;
    user-select: none;
  }

  #random-walk a:hover {
    background-color: #333;
    border-color: #eee;
    color: #eee;
    opacity: 1;
  }

  .random-walk-chosen {
    outline: 1px solid #9cc;
  }

  #rw-seek.rw-seeking {
    background-color: #161;
    color: #7f7;
    opacity: 1;
  }
  #rw-seek.rw-seeking:hover {
    background-color: #191;
    color: #111;
  }
</style><</append>>

<<script>>
const MT = window.MagesTower || (window.MagesTower = {});

const visited = new Set();
let lastPick = {};

MT.forgetWalkHistory = () => {
  visited.clear();
  lastPick = {};
};

const pathIgnore = [
  "Bound",
  "Choose Character",
];

/**
 * Returns a traversable path from the current play log.
 * Path is an array of next-passage titles or objects.
 * Object is when a passage has multiple links to the next-passage.
 * If a passage only has next-passage, that next-passage can be omitted.
 */
MT.getPath = () => {
  const path = [];
  const log = MagesTower.log;
  if (log == null || log.length === 0) return [];
  if (log[0].title !== "Bound") return [];

  for (let i = 0; i < log.length; i++) {
    if (i > 0 && i < log.length - 1 && log[i - 1].noChoice) continue;
    const entry = log[i];
    if (pathIgnore.includes(entry.title)) continue;
    if (entry.mtaCode != null) {
      path.push({ code: entry.mtaCode, title: entry.title });
    } else {
      path.push(entry.title);
    }
  }
  return path;
};

/** Random walk */
function initRandomWalk() {
  if (!setup.tester) return;

  const idOf = el => {
    const title = $(el).attr("data-passage");
    const mtaCode = $(el).attr("data-mta-code");
    return `${title}/${mtaCode}`;
  };

  const goRandom = () => {
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      chosen.click();
      return true;
    }
    chosen.removeClass("random-walk-chosen");

    const here = State.passage;
    const all = $("#passages a[data-passage]");
    if (all.length === 0) return false;

    let avail = all.filter((i, el) => !visited.has(idOf(el)));
    let pick = null;
    while (pick == null) {
      if (avail.length === 0) {
        all.each((i, el) => visited.delete(idOf(el)));
        avail = all;
        if (avail.length > 1) {
          // avoid picking the link we just picked
          avail = avail.filter((i, el) => idOf(el) !== lastPick[here]);
          if (avail.length === 0) avail = all;
        }
      }

      // Should not use State.random()
      const i = Math.floor(avail.length * Math.random());
      pick = avail[i];
      const code = $(pick).attr("data-mta-code");
      const avoid = code != null && code.includes("//avoid");
      if (avoid && Math.random() < .9) {
        const title = $(pick).attr("data-passage");
        console.log(`avoiding ${title}`);
        pick = null;
        avail.splice(i, 1);
      }
    }
    $(pick).addClass("random-walk-chosen");
    pick.scrollIntoView(false);
    lastPick[here] = idOf(pick);
    visited.add(lastPick[here]);
    return true;
  };

  const goBack = () => {
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length > 0) {
      chosen.removeClass("random-walk-chosen");
    } else {
      Engine.backward();
    }
  };

  const goForward = () => {
    if (State.length === State.size) {
      goRandom();
      return;
    }

    const next = State.history[State.length].title;
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      if (chosen.attr("data-passage") === next) {
        Engine.forward();
      } else {
        goRandom();
      }
      return;
    }
    chosen.removeClass("random-walk-chosen");
    const links = $("#passages a[data-passage]")
      .filter((i, el) => $(el).attr("data-passage") === next);
    if (links.length === 1) {
      links.addClass("random-walk-chosen");
      links[0].scrollIntoView(false);
    } else {
      Engine.forward();
    }
  };

  let seeking = false;
  let seekForce = false;
  let seekLoop = false
  let seekMoved = false;
  let seekPath = null;

  const seekDelay = 50;

  const seekToggle = () => {
    if (seeking) {
      seekStop();
    } else {
      seekStart();
    }
  };

  const seekStart = MagesTower.seekStart = path => {
    $("#rw-seek").addClass("rw-seeking");
    seeking = true;
    seekMoved = false;
    seekPath = path;
    setTimeout(seekNext, seekDelay);
  };

  const seekStop = () => {
    seeking = false;
    seekPath = null;
    $("#rw-seek").removeClass("rw-seeking");
  };

  const seekNext = () => {
    const here = State.passage;

    if (!seeking) return seekStop();
    if (seekMoved && here === Config.passages.start) return seekStop();

    const done = tags().includes("done");
    if (seekMoved && done) {
      const steps = MagesTower.log.length;
      console.log(`done after ${steps} steps at ${here}`);
    }
    if (seekMoved && done && !seekLoop) return seekStop();
    if (done) {
      MagesTower.forgetWalkHistory();
      Engine.play("Bound");
      seekLoop = true;
      seekForce = false;
      // seekForce = true;
      MagesTower.seekStart(["n1a/F Nero Start"]);
      return;
    }

    let hasProblem = false;
    hasProblem = hasProblem || ErrorMessage.hasFails;
    hasProblem = hasProblem || ErrorMessage.hasWarnings;
    hasProblem = hasProblem ||
        /\bX[X]X\b|\bTO[D]O\b/.test($(".passage").text());

    let isDraft = /[/][DPS]/.test(here);

    if (hasProblem || (isDraft && !seekForce)) {
      if (seekMoved) return seekStop();
      seekForce = true;
    }

    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      seekMoved = true;
      chosen[0].click();
      setTimeout(seekNext, seekDelay);
      return;
    }

    if (seekLoop && seekPath != null && seekPath.length === 0) {
      seekPath = null;
    }

    if (seekPath != null) {
      if (seekPath.length === 0) return seekStop();
      const next = seekPath[0];
      const links = $("#story a[data-passage]");
      const isStep = (el, step) => {
        const title = el.getAttribute("data-passage");
        const code = el.getAttribute("data-mta-code");
        if (typeof step === "string") {
          return title === step;
        } else {
          return title === step.title && code === step.code;
        }
      };
      for (const link of links) {
        if (isStep(link, next)) {
          seekPath.shift();
          $(link).addClass("random-walk-chosen");
          setTimeout(seekNext, 100);
          return;
        }
      }
      if (links.length === 1) {
        links.addClass("random-walk-chosen");
        setTimeout(seekNext, seekDelay);
        return;
      }

      ErrorMessage.warn(`Broken path: ${JSON.stringify(next)}`);
      return seekStop();
    }

    if (goRandom()) {
      setTimeout(seekNext, seekDelay);
      return;
    }
    
    seekStop();
  };

  $(() => {
    $("#random-walk").remove();
    const outer = $("<div>")
      .attr("id", "random-walk")
      .appendTo("#story");
    $("<a>")
      .attr("title", "<ctrl-comma> backward")
      .text("back")
      .click(goBack)
      .appendTo(outer);
    if (setup.debug) {
      $("<a id=rw-seek>")
        .attr("title", "<ctrl-backslash> seek")
        .toggleClass("rw-seeking", seeking)
        .text("seek")
        .click(seekToggle)
        .appendTo(outer);
      $("<a>")
        .attr("title", "<ctrl-slash> random")
        .text("rand")
        .click(goRandom)
        .appendTo(outer);
    }
    $("<a>")
      .attr("title", "<ctrl-period> forward")
      .text("forw")
      .click(goForward)
      .appendTo(outer);
  });

  // ctrl-comma doesn't generate keypress events
  $(document).on("keydown", ev => {
    if (!ev.ctrlKey) return;
    const focus = document.activeElement;
    const tag = focus != null ? focus.tagName : "";
    if (/^(textarea|input|select)$/i.test(tag)) return;
    if (ev.key === ",") return goBack();
    if (ev.key === ".") return goForward();
    if (ev.key === "/") return goRandom();
    if (ev.key === "\\") return seekToggle();
  });

  $(document).on("click", ev => {
    if (ev.target && ev.target.tagName !== "A") {
      const chosen = $("#passages .random-walk-chosen");
      chosen.removeClass("random-walk-chosen");
    }
  });
}

initRandomWalk();
<</script>>
