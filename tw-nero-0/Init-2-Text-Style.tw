:: Init 2 Text Style [inclusion] {"position":"2850,700","size":"100,100"}
<<append head>><style>

em {
  margin-right: 0.05em;
}

em em {
  font-weight: bold;
  margin-right: 0;
  text-decoration: underline;
}

.sprite-q {
  color: #6d6;
}

meta-text {
  background-color: transparent;
  color: #eaf54c;
  display: inline;
  font-style: italic;
}
meta-ending-bad {
  color: #f44;
  font-style: italic;
  font-weight: bold;
}
meta-ending-good {
  color: #6e6;
  font-style: italic;
  font-weight: bold;
}

</style><</append>>

<<script>>
const MT = MagesTower;

function announceEnding(dest, type, vname, text) {
  const V = State.variables;
  if (!V[vname]) {
    $(dest).append(
      `<meta-text>${text} is now unlocked in the Archive.</meta-text>`);
    V[vname] = true;
  } else {
    $(dest).append(`<meta-ending-${type}>${text}</meta-ending-${type}>`);
  }
}

/**
 * <<meta-ending [good|bad] varname1 text1>>
 * Announce an ending. If it's locked, unlock it, and announce the unlocking.
 */
Macro.add("meta-ending", {
  handler: function() {
    const [type, vn1, text1] = this.args;
    const V = State.variables;
    announceEnding(this.output, type, vn1, text1);
  }
});

/**
 * Join a list of strings, filtering out null and false and "" values.
 * 
 * opt is {
 *   sep: string;       // separator for more than 2
 *   sep2?: string;     // separator for exactly 2
 *   sepLast?: string;  // separator before last, when more than 2
 * }
 */
MT.join = (opt, strings) => {
  const s = strings.filter(s => s != null && s !== false && s !== "");
  if (s.length < 2) {
    return s.join("");
  } else if (s.length === 2) {
    return `${s[0]}${opt.sep2 || opt.sep}${s[1]}`;
  } else {
    const last = s.pop();
    return s.join(opt.sep) + (opt.sepLast || opt.sep) + last;
  }
};

/**
 * Join a list of strings with commas and "and".
 */
MT.joinComma = (strings) => {
  const opt = { sep: ", ", sep2: " and ", sepLast: ", and" }
  return join(opt, strings);
};

<</script>>