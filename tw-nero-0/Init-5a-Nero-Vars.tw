:: Init 5a Nero Vars [inclusion] {"position":"3000,1000","size":"100,100"}
<<script>>
// This has a :passagestart that should run before any other Nero :passagestart

EnumType.define("MagicPhase", [
  "MP_beforeCast",
  "MP_triedMagic",
  "MP_mageSight",
  "MP_wantDevice",
  "MP_wantName",
  "MP_wantTouch",
  "MP_wantPass",
  "MP_onHold",
  "MP_contact",
  "MP_lockedOut",
  "MP_drained", // had mageSight, but didn't connect to Sprite
  "MP_tapLost",  // did connect to Sprite
]);
EnumType.declareVar("n1_magicPhase", "MagicPhase");
EnumType.declareVar("n2_magicPhaseLost", "MagicPhase");

/*
 * Places where Ivex has asked a question, and may be near enough to hear
 * Nero trying to talk to the Sprite.
 */
EnumType.define("IvexContext", [
  "IC_unknown",
  "IC_gone",
  "IC_distant",
  "IC_explainTheft", // recruit > Ivex Trap
  "IC_lickPaw", // subby > Ivex Dominant
  "IC_begForMe", // subby > Ivex Cruel
  "IC_comfortable", // candle lit > Comfort Check
  "IC_whoSentYou", // candle horny > Light Squeeze, Heavy Squeeze
]);
EnumType.declareVar("t_ivexContext", "IvexContext");


// Define temp var with a getter, so read tracking works.
function defTemp(vname, fn) {
  Object.defineProperty(State.temporary, vname, { enumerable: true, get: fn });
}

$(document).on(":passagestart", () => {

  // Ivex ran out of patience in the most-recent action node.
  defTemp("ivexAngry", () => {
    const V = State.variables;
    return V.t_patienceActions === 0 || V.t_patienceLooks === 0;
  });

  // Nero thinks he only has one chance left.
  defTemp("passDesperate", () => {
    const V = State.variables;
    const n = (V.n1_passFailed || []).length;
    return (MP_onHold === V.n1_magicPhase && n === 1) ||
      (MP_wantPass === V.n1_magicPhase && n === 2);
  });

  // Initialize enums that are generally expected to be non-null
  VarTrace.ignore(() => {
    const V = State.variables;
    V.n1_magicPhase != null || (V.n1_magicPhase = 0);
    V.t_ivexContext != null || (V.t_ivexContext = 0);
  });
});
<</script>>
