:: Init 2 Log [inclusion] {"position":"2550,600","size":"100,100"}
<<append head>><style>

#log-button {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 4px;
    color: #000;
    cursor: pointer;
    font-size: 18px;
    min-width: 2em;
    opacity: 0.1;
    padding: 2px 4px;
    position: fixed;
    right: 4px;
    text-align: center;
    top: 90px;
    z-index: 20;
}
#log-button:hover {
  background-color: #333;
  border-color: #eee;
  color: #eee;
  opacity: 1;
}

#log-outer {
  max-width: min(90vw, 40em);
}

#log-outer a {
  color: #aac;
  cursor: text;
}
#log-outer ul.actions a {
  color: #669;
}
#log-outer#log-outer a.log-next {
  color: #6ef;
}

#log-outer ul.actions li::before {
  filter: saturate(0);
}

#log-outer hr {
  border-color: #333;
}

#log-outer .random-walk-chosen {
  outline: none;
}

#log-outer .log-title {
  border-bottom: 1px solid #666;
  margin-bottom: 12px;
  text-align: right;
}

#log-outer .log-title span {
  background-color: #333;
  border: 1px solid #666;
  border-bottom: 0;
  border-radius: 6px 6px 0 0;
  color: #999;
  display: inline-block;
  font-size: 12px;
  opacity: 0.8;
  padding: 2px 6px;
}
#log-outer .log-title span:hover {
  border-color: #fff;
  background-color: #111;
  color: #fff;
  opacity: 1;
}

</style><</append>>

<<script>>
/*
 * This module provides a story transcript of a play session, by taking
 * snapshots of the rendered html of each passage.
 *
 * In principle, we could reconstruct the transcript by replaying the path.
 * SugarCube has an option for deterministic rng, but its implementation is
 * awkward. We'd have to manage the rng state ourselves.
 *
 * If we want to expose transcript to players, we should probably try to that,
 * because replay from path is a much smaller savestate than html snapshot.
 * (Note, we can't just use passage history, we have to save rng state
 * and disambiguation for links with setters.)
 */

const MT = window.MagesTower || (window.MagesTower = {});

const KEY = "mt-log-1";

/**
 * Array of entries of everything before current passage.
 * Entry is:
 * - turn: number - history turn
 * - title: string - passage title
 * - html: string - html snapshot
 * - mtaCode: string - disambiguator if prev has multiple links here
 * - noChoice: boolean - true if there's only one link out from here
 * - pending: boolean - true if this was before visiting a noreturn passage
 */
MT.log = [];

/**
 * passageinit can trigger after momentActivate, which means State
 * isn't necessarily what's currently displayed.
 * This keeps track of what's currently visible.
 * - turn: number
 * - title: string
 */
MT.displayedPassage = null;

function saveLog() {
  State.metadata.set(KEY, MT.log);
}

function initLog() {
  if (!setup.tester) return;

  MT.log = State.metadata.get(KEY) || [];

  $("<div id=log-button>")
    .appendTo("#story")
    .text("log")
    .on("click", () => openLog());

  $(document).on(":passageinit", captureOnExit);
  $(document).on(":passagedisplay", captureOnEnter);
}

/**
 * Runs at passageinit to capture the displayed passage,
 * before it gets overwritten with the next passage.
 */
function captureOnExit(ev) {
  const next = ev.passage;
  if (next == null) return;

  const dp = MT.displayedPassage;
  if (dp == null) return;

  if (MT.log.length === 0) return;

  // Any passage we want to log, should already have an entry
  const entry = MT.log[MT.log.length - 1];
  if (entry.title !== dp.title || entry.turn !== dp.turn) return;

  const jq = $(".passage");
  entry.pending = next.tags.includes("noreturn");
  entry.noChoice = jq.find("a[data-passage]").length <= 1;
  const nextCode = MagesTower.mtaCode(next.title);
  entry.html = cleanHtml(jq, next.title, nextCode);
  saveLog();
}

/** Runs at passagedisplay to capture the just-rendered passage */
function captureOnEnter(ev) {
  MT.displayedPassage = null;

  const title = State.passage;
  const turn = State.turns;
  const mtaCode = MagesTower.mtaCode();

  if (tags().includes("noreturn")) return;
  if (title === "Title Screen") return;

  MT.displayedPassage = { turn, title };
  
  // If we're starting over, clear log.
  if (title === "Bound") {
    MT.log = [];
  }

  // Remove future entries
  MT.log = MT.log.filter(e => e.turn < turn);
  
  let entry = { title, turn, mtaCode };

  // If we returned from a noreturn, we should update an existing entry
  if (MT.log.length > 0) {
    const last = MT.log[MT.log.length - 1];
    if (last.pending && last.title === title) {
      const pTitle = State.peek(-1).title;
      const prev = Story.get(pTitle);
      if (prev.tags.includes("noreturn")) {
        MT.log.pop();
        entry = last;
        entry.turn = turn;
        // keep old mtaCode
      }
    }
  }

  MT.log.push(entry);

  entry.pending = true;

  const jq = $(".passage");
  entry.noChoice = jq.find("a[data-passage]").length <= 1;
  entry.html = cleanHtml(jq, null, null);
  saveLog();
}

/**
 * Returns a cleaned up html string of the passage at jq.
 * nextTitle and nextCode are used to highlight the link being followed.
 */
function cleanHtml(jq, nextTitle, nextCode) {
  jq = jq.clone();
  jq.removeClass("passage-in");
  jq.find(".random-walk-chosen").removeClass("random-walk-chosen");
  jq.find(".fade-in-hidden").removeClass("fade-in-hidden");
  jq.find(".fade-in-absorb").removeClass("fade-in-absorb");
  jq.find(".tame-hide").removeClass("tame-hide");
  jq.find(".log-remove").remove();
  jq.find("[data-name=silently]").remove();
  jq.find(".patience-debug").remove();
  jq.find(".ro-debug").remove();
  jq.find(".debug").replaceWith(function() { return $(this).contents(); });

  // highlight the link followed.
  if (nextTitle != null) {
    let link = jq.find(`a[data-passage="${nextTitle}"]`);
    if (link.length > 1 && nextCode != null) {
      link = link.filter(`[data-mta-code="${nextCode}"]`);
    }
    link.addClass("log-next");
  }

  // remove trailing br
  while (jq[0].lastChild != null && jq[0].lastChild.tagName === "BR") {
    jq[0].lastChild.remove();
  }

  return jq[0].outerHTML;
}

function openLog() {
  Dialog.setup("");
  const outer = $("<div id=log-outer>").appendTo(Dialog.body());
  let words = 0;
  MT.log.forEach((e, i) => {
    if (e.pending && e.title === State.passage) return;
    $("<div class=log-title>")
      .append($("<span>").text(e.title))
      .appendTo(outer);
    const section = $.parseHTML(e.html);
    outer.append(section);
    words += MagesTower.countWords($(section).text());
  });

  const json = JSON.stringify(MT.log);
  const compressed = LZString.compressToBase64(json);
  console.log({ logJson: json.length, compressed: compressed.length });

  const minutes = Math.round(words / 250);
  $("#ui-dialog-title")
    .append(`~${minutes} min`)
    .append(` | ${MT.log.length} p`)
    .append(` | ${words} w`)
    .append(` | ${compressed.length} z`);

  $("<a>&#x2191; </a>").prependTo("#ui-dialog-title")
    .on("click", () => {
      const divs  = $("#log-outer > div.log-title");
      if (divs.length) divs[0].scrollIntoView();
    });
  $("<a> &#x1f3b2;</a>").appendTo("#ui-dialog-title")
    .on("click", () => {
      const divs = $("#log-outer > div.log-title");
      if (divs.length) {
        // Should not use State.random()
        const i = Math.floor(divs.length * Math.random());
        divs[i].scrollIntoView();
      }
    });
  $("<a> &#x2193;</a>").appendTo("#ui-dialog-title")
    .on("click", () => {
      const divs = $("#log-outer > div.log-title");
      if (divs.length) divs[divs.length - 1].scrollIntoView();
    });

  Dialog.open();
}

initLog();
<</script>>
