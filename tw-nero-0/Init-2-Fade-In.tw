:: Init 2 Fade-In [inclusion] {"position":"3150,500","size":"100,100"}
<!--
/*
 * This description assumes you're using the default style.
 * <<fade-in 1.5s [no-pulse]>>
 *    A pulsing "..." appears here.
 *    After 1.5 seconds, this section's text fades in.
 *    Click/tap on the "..." will skip the delay.
 *    Links in this section are shown without delay, in their proper location,
 *    but blocked out with a gray rectangle.
 *    Click/tap on any blocked-out link will also skip the delay.
 * <<fade-next 1s>>
 *    After the first section has faded-in, the "..." appears here.
 *    After another 1s, this section's text fades in.
 *    There can be any number of "next" sections.
 * <</fade-in>>
 */
-->

<<append head>><style>
  /* <span> for each fade-in section */
  .fade-in {
    transition: all .4s ease-in;
  }

  /*
   * Hide text. Note: using opacity or filter here will make it impossible
   * to have links visible (child filter cannot override parent).
   * The :not clause gives this rule a high CSS specificity, making this
   * more likely to override complex selectors elsewhere.
   */
  .fade-in-hidden:not(#give#this#rule#high#specificity),
  .fade-in-hidden:not(#give#this#rule#high#specificity) * {
    background-image: unset;
    color: rgba(0, 0, 0, 0);
    pointer-events: none;
  }

  /* Hide media. */
  .fade-in-hidden:not(#give#this#rule#high#specificity) img,
  .fade-in-hidden:not(#give#this#rule#high#specificity) video {
    opacity: 0;
  }

  /* actions list image */
  .fade-in-hidden:not(#give#this#rule#high#specificity) li::before {
    background-image: unset;
  }

  /* Block-out hidden links. */
  .fade-in-hidden:not(#give#this#rule#high#specificity) a {
    background-color: #222;
    border-radius: 4px;
    color: rgba(0, 0, 0, 0);
    pointer-events: auto;
  }
  .fade-in-hidden:not(#give#this#rule#high#specificity) a:hover {
    background-color: #333;
    color: rgba(0, 0, 0, 0);
  }

  /* Put pulsing dots at the section that will be revealed next. */
  .fade-in-next:not(#give#this#rule#high#specificity)::before {
    animation: 0.5s 1s ease-in-out alternate both infinite fade-in-blink;
    color: #fff;
    content: ". . .";
    cursor: pointer;
    display: inline-block;
    font-weight: bold;
    pointer-events: auto;
    position: absolute;
  }
  @keyframes fade-in-blink {
    from { opacity: 0.4; }
    to { opacity: 1; }
  }

  .fade-in-no-pulse.fade-in-next:not(#give#this#rule#high#specificity)::before {
    animation: none;
    opacity: 0.6;
  }

  /* Absorb clicks for a small amount of time after fade-in. */
  .fade-in-absorb:not(#give#this#rule#high#specificity),
  .fade-in-absorb:not(#give#this#rule#high#specificity) *,
  .fade-in-absorb:not(#give#this#rule#high#specificity) *:hover {
    cursor: wait;
  }
  .fade-in-absorb:not(#give#this#rule#high#specificity) a,
  .fade-in-absorb:not(#give#this#rule#high#specificity) a:hover {
    color: rgb(100, 100, 100, 1);
  }
</style><</append>>

<<script>>
/*
 * Sometimes a player will click with intent to skip, but fade-in will
 * happen almost at the same time, and the click will land after the
 * fade-in happens. This is annoying if the click lands on a link and
 * follows it. So we absorb clicks a small amount of time after
 * automatic fade-in.
 */
const absorbMsec = 500;

Macro.add("fade-in", {
  tags: ["fade-next"],
  handler: function() {
    const queue = [];
    let timeout = null;

    const next = () => {
      if (timeout != null) clearTimeout(timeout);
      if (queue.length === 0) return;
      const [delay, span] = queue[0];
      span.addClass("fade-in-next");
      timeout = setTimeout(() => {
        if (span.hasClass("fade-in-hidden")) {
          span.addClass("fade-in-absorb");
          setTimeout(() => span.removeClass("fade-in-absorb"), absorbMsec);
        }
        span.removeClass("fade-in-hidden fade-in-next");
        if (queue[0][1] === span) {
          queue.shift();
          next();
        }
      }, delay);
    };

    const skipTo = jq => {
      const pos = queue.findIndex(q => q[1] === jq);
      if (pos < 0) return;
      for (let i = 0; i <= pos; i++) {
        const span = queue.shift()[1];
        span.removeClass("fade-in-hidden fade-in-next");
      }
      next();
    };

    for (const section of this.payload) {
      const noPulse = section.args[1] === "no-pulse";
      let delay = Util.fromCssTime(section.args[0]);
      delay = Math.max(delay, Engine.minDomActionDelay);
      if (MagesTower.seeking) delay = 0;
      const span = $("<span>")
        .addClass("fade-in fade-in-hidden")
        .toggleClass("fade-in-no-pulse", noPulse)
        .wiki(section.contents)
        .appendTo(this.output);
      const hurry = ev => {
        span[0].removeEventListener("click", hurry, true);
        if (span.hasClass("fade-in-absorb")) {
          ev.preventDefault();
          ev.stopPropagation();
        } else if (span.hasClass("fade-in-hidden")) {
          span.removeClass("fade-in-hidden fade-in-next");
          span.addClass("fade-in-absorb");
          setTimeout(() => span.removeClass("fade-in-absorb"), absorbMsec);
          ev.preventDefault();
          ev.stopPropagation();
          skipTo(span);
        }
      };
      span[0].addEventListener("click", hurry, true);
      queue.push([delay, span]);
    }

    setTimeout(next);
  }
});
<</script>>
