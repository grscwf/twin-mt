:: n0-F Walk To Script [inclusion] {"position":"3200,1475","size":"100,100"}
<<script>>

const MT = MagesTower;
window.MT = MagesTower;

State.temporary.listWalks = () => {
  const walks = MT.walks;
  const current = MT.getPath();
  let mkp = "<<nobr>>";
  for (let i = 0; i < walks.length; i++) {
    if (typeof walks[i] === "string") {
      mkp += `<div class="walk-header">${walks[i]}</div>`;
      continue;
    }

    const addSeg = (ch, type, width) => {
      if (width != null) mkp += `<span class=walk-sp>`;
      if (width != null) mkp += `<span class=walk-sp-w>> ${width}</span>`;
      mkp += `<span class="walk-choice walk-choice-${type}">`;
      mkp += `<<link "> ${ch}">>`;
      mkp += `<<run _doWalk(${i}, "${ch}")>>`;
      mkp += `<</link>>`;
      if (width != null) mkp += `</span>`;
      mkp += `</span> `;
    };

    const path = walks[i].path;
    const [pn, cn] = MT.commonPathLengths(path, current);

    mkp += `<div class=walk-path>`;
    if (pn === path.length) {
      /* all of path is in the past of current */
      for (const st of path) {
        if (st.choice != null) addSeg(st.choice, "past", st.width);
      }
    } else if (cn === current.length) {
      /* all of current is on path */
      /* find finished choice in path */
      let ppn = pn;
      while (ppn > 1 && path[ppn].choice == null) ppn--;
      for (const st of path.slice(0, ppn)) {
        if (st.choice != null) addSeg(st.choice, "past", st.width);
      }
      for (const st of path.slice(ppn)) {
        if (st.choice != null) addSeg(st.choice, "future", st.width);
      }
    } else {
      /* path and current are disjoint */
      for (const st of path) {
        if (st.choice != null) addSeg(st.choice, "disjoint", st.width);
      }
    }
    mkp += `<span class=walk-path-len>[${path.length}]</span>`;
    mkp += `</div>`;
  }
  mkp += "<</nobr>>";
  return mkp;
};

function getPathChoice(path, ch) {
  const result = [];
  let seen = false;
  for (const step of path) {
    if (step.choice != null && seen) break;
    result.push(step);
    if (step.choice != null) seen = step.choice === ch;
  }
  return result;
}

function setVars(vars) {
  if (vars != null) {
    for (const vn of Object.keys(vars)) {
      State.variables[vn] = vars[vn];
    }
  }
}

State.temporary.doWalk = (i, ch) => {
  MagesTower.forgetWalkHistory();
  const walk = MT.walks[i];
  const path = getPathChoice(walk.path, ch);
  Engine.play("Bound");
  setVars(walk.vars);
  MT.seekStart(path);
};

State.temporary.reWalk = () => {
  const path = MT.getPath();
  MagesTower.forgetWalkHistory();
  Engine.play("Bound");
  MT.seekStart(path);
};

State.temporary.showCurrentPath = () => {
  const path = MT.getPath();
  const js = MT.pathToJs(path);
  $("#walk-current-path").val(`// current path [${path.length}]\n${js}`);
};

State.temporary.walkAll = () => {
  const walks = MT.walks;
  let i = 0;
  const next = () => {
    while (i < walks.length && walks[i].path == null) i++;
    if (i >= walks.length) {
      console.log("done walkAll");
      return;
    }
    const walk = walks[i++];
    console.log(`Starting ${MT.pathName(walk.path)}`);
    Engine.play("Bound");
    setVars(walk.vars);
    MT.seekStart(walk.path, next);
  };
  next();
}

<</script>>\
