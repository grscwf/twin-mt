:: Init Random Walk [inclusion] {"position":"2950,600","size":"100,100"}
<<append head>><style>
  #random-walk {
    top: max(5rem, 50vh - 5rem);
    display: flex;
    flex-direction: column;
    font-size: 18px;
    gap: 20px;
    position: fixed;
    right: 4px;
    z-index: 20;
  }

  #random-walk a {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 4px;
    color: #000;
    cursor: pointer;
    opacity: 0.1;
    padding: 2px 4px;
    text-align: center;
    user-select: none;
  }

  #random-walk a:hover {
    background-color: #333;
    border-color: #eee;
    color: #eee;
    opacity: 1;
  }

  .random-walk-chosen {
    outline: 1px solid #9cc;
  }

  #rw-seek.rw-seeking {
    background-color: #161;
    color: #7f7;
    opacity: 1;
  }
  #rw-seek.rw-seeking:hover {
    background-color: #191;
    color: #111;
  }
</style><</append>>

<<script>>

const milestones = new Set([
  "n1p-F Barbs Fast 1",
  "n1p-F Barbs Slow 1",
  "n1p-F Barbs Slow 2a1",
  "n1p-F Barbs Slow 2n1",
  "n1p-F Barbs Slow 2s1",
  "n1p-F Barbs Skip",
  "n1s-F Cast Alone 1",
  "n1s-F Cast Endgame 1",
  "n1s-F Cast Horny 1",
  "n1s-F Cast Itch 2",
  "n1s-F Cast Sight 1",
  "n1s-F Cast Sight Horny",
  "n1s-F Cast Younger 1",
  "n1s-F Guess Password",
  "n1s-F Impatient",
  "n1s-F Say Device",
  "n1s-F Say Lance",
  "n1s-F Say Password",
  "n1s-F Tap 1",
  "n1s-F Zero Bound",
]);

const visited = new Set();
let lastPick = {};

let ignoreFuture = false;

MT.seeking = false;

MT.forgetWalkHistory = () => {
  visited.clear();
  lastPick = {};
};

/** Random walk */
function initRandomWalk() {
  if (!setup.tester) return;

  const idOf = el => {
    const title = $(el).attr("data-passage");
    const mtaCode = $(el).attr("data-mta-code");
    return `${title}/${mtaCode}`;
  };

  function updateLabel() {
    const el = $("#rw-forw");
    if (State.length === State.size || ignoreFuture) {
      el.text("rand");
    } else {
      el.text("forw");
    }
  }

  const goRandom = () => {
    const V = State.variables;

    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      ignoreFuture = false;
      chosen.click();
      return true;
    }
    chosen.removeClass("random-walk-chosen");

    const here = State.passage;
    const all = $("#passages a[data-passage]");
    if (all.length === 0) return false;

    let avail = all;

    // bias toward climbing the ladder of magic.
    let important = "[data-mta-code*='//prefer']";
    switch (V.n1_magicPhase) {
      case MP_beforeCast:
        important += ", [data-passage*=Cast]:not([data-passage*=Itch])";
        break;
      case MP_triedMagic:
        if (!V.n1_mageSight) {
          important += ", [data-passage*=Sight]";
        } else {
          important += ", [data-passage*=Mirror], [data-passage*=Tap]";
        }
        break;
      case MP_wantDevice:
        important += ", [data-passage*=Say]";
        break;
      case MP_wantName:
        important += ", [data-passage*=Say], [data-passage*=Ask]";
        important += ", [data-passage*=Bottle]";
        break;
      case MP_wantTouch:
        important += ", [data-passage*=Ask], [data-passage*=Penguin]";
        break;
      case MP_wantPass:
        important += ", [data-passage*=Password], [data-passage*=Ask]";
        break;
    }
    const prefer = all.filter(important);
    if (prefer.length && Math.random() < .7) {
      const names = prefer.map((i, el) => $(el).attr("data-passage"));
      console.log(`prefer [${[...names].join(",")}]`);
      avail = prefer;
    } else {
      avail = avail.filter((i, el) => !visited.has(idOf(el)));
    }
    let pick = null;
    while (pick == null) {
      if (avail.length === 0) {
        all.each((i, el) => visited.delete(idOf(el)));
        avail = all;
        if (avail.length > 1) {
          // avoid picking the link we just picked
          avail = avail.filter((i, el) => idOf(el) !== lastPick[here]);
          if (avail.length === 0) avail = all;
        }
      }

      // Should not use State.random()
      const i = Math.floor(avail.length * Math.random());
      pick = avail[i];
      const code = $(pick).attr("data-mta-code");
      const avoid = code != null && code.includes("//avoid");
      if (avoid && Math.random() < .9) {
        const title = $(pick).attr("data-passage");
        console.log(`avoiding ${title}`);
        pick = null;
        avail.splice(i, 1);
      }
    }
    $(pick).addClass("random-walk-chosen");
    pick.scrollIntoView(false);
    lastPick[here] = idOf(pick);
    visited.add(lastPick[here]);
    return true;
  };

  const goBack = () => {
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length > 0) {
      ignoreFuture = true;
      chosen.removeClass("random-walk-chosen");
      updateLabel();
    } else {
      ignoreFuture = false;
      Engine.backward();
    }
  };

  const goForward = () => {
    if (State.length === State.size || ignoreFuture) {
      goRandom();
      return;
    }
    ignoreFuture = false;

    const next = State.history[State.length].title;
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      if (chosen.attr("data-passage") === next) {
        Engine.forward();
      } else {
        goRandom();
      }
      return;
    }
    chosen.removeClass("random-walk-chosen");
    const links = $("#passages a[data-passage]")
      .filter((i, el) => $(el).attr("data-passage") === next);
    if (links.length === 1) {
      links.addClass("random-walk-chosen");
      links[0].scrollIntoView(false);
    } else {
      Engine.forward();
    }
  };

  let seekForce = false;
  let seekLoop = 0;
  let seekLooping = false;
  let seekMoved = false;
  let seekPath = null;
  let seekDoneFn = null;

  const seekDelay = 50;
  const maxLoop = 5;

  const seekToggle = () => {
    if (MT.seeking) {
      seekStop();
    } else {
      seekStart();
    }
  };

  const seekStart = MT.seekStart = (path, doneFn, force) => {
    $("#rw-seek").addClass("rw-seeking");
    MT.seeking = true;
    seekForce = force;
    seekMoved = false;
    seekPath = path;
    seekDoneFn = doneFn;
    setTimeout(seekNext, seekDelay);
  };

  const seekStop = () => {
    MT.seeking = false;
    seekPath = null;
    seekDoneFn = null;
    $("#rw-seek").removeClass("rw-seeking");
  };

  const seekNext = () => {
    const here = State.passage;

    if (!MT.seeking) return seekStop();
    if (seekMoved && here === Config.passages.start) return seekStop();

    let hasProblem = false;
    hasProblem = hasProblem || MT.hasFails;
    hasProblem = hasProblem || MT.hasWarnings;
    hasProblem = hasProblem || $(".error-view").length !== 0;

    let hasTodo = /\bX[X]X\b|\bTO[D]O\b/.test($(".passage").text());

    const isDraft = MT.isDraft(here);
    const done = tags().includes("done");

    if (seekMoved) {
      if (hasProblem) {
        console.log('stopping on problem');
        return seekStop();
      }
      if (!seekForce && (hasTodo || isDraft)) {
        console.log('stopping on to-do');
        return seekStop();
      }
      if (done) {
        const steps = MT.log.length;
        const V = State.variables;
        console.log(`done after ${steps} steps at ${here}`);
        const mp = MT.enumSymbol('MagicPhase', V.n1_magicPhase);
        const mpr = MT.enumSymbol('MagicPhase', V.n1_magicPhaseReached);
        console.log(`- magicPhase ${mp}, ${mpr}`);
        if (seekLoop <= 0) {
          if (seekLooping) {
            seekLooping = false;
            console.log("stop at max loops");
          }
          return seekStop();
        }
      }
    }

    if (!seekMoved) {
      if (hasTodo || isDraft) {
        seekForce = true;
      }
      if (done) {
        seekLoop = maxLoop;
        seekLooping = true;
      }
    }

    if (done) {
      seekLoop--;
      if (seekLoop <= 0) {
        seekLooping = false;
        console.log("stop at max loops");
        return seekStop();
      }
      MT.forgetWalkHistory();
      Engine.play("Bound");
      seekForce = false;
      const neroStart = [
        { t: "Choose Character" },
        { t: "n1a-F Nero Start" },
      ];
      MT.seekStart(neroStart, () => {
        MT.seekStart();
      });
      return;
    }

    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      seekMoved = true;
      chosen[0].click();
      setTimeout(seekNext, seekDelay);
      return;
    }

    if (seekLoop && seekPath != null && seekPath.length === 0) {
      seekPath = null;
    }

    if (seekPath != null) {
      while (seekPath.length && seekPath[0].t == null) {
        seekPath.shift();
      }
      if (seekPath.length === 0) {
        const steps = MT.log.length;
        console.log(`path end after ${steps} steps at ${here}`);
        if (seekDoneFn != null) setTimeout(seekDoneFn);
        seekStop();
        return;
      }
      const next = seekPath[0];
      const links = $("#story a[data-passage]");
      const isStep = (el, step) => {
        const title = el.getAttribute("data-passage");
        const code = el.getAttribute("data-mta-code") || null;
        return title === step.t && code === (step.code || null);
      };
      for (const link of links) {
        if (isStep(link, next)) {
          seekPath.shift();
          $(link).addClass("random-walk-chosen");
          setTimeout(seekNext, 100);
          return;
        }
      }

      let msg = `Broken path: ${JSON.stringify(next)}`;
      MT.warn(msg);
      return seekStop();
    }

    if (milestones.has(here)) {
      console.log(`milestone ${here}`);
    }

    if (goRandom()) {
      setTimeout(seekNext, seekDelay);
      return;
    }
    
    seekStop();
  };

  $(() => {
    $("#random-walk").remove();
    const outer = $("<div>")
      .attr("id", "random-walk")
      .appendTo("#story");
    $("<a>")
      .attr("title", "<ctrl-comma> backward")
      .text("back")
      .click(goBack)
      .appendTo(outer);
    if (setup.debug) {
      $("<a id=rw-seek>")
        .attr("title", "<ctrl-backslash> seek")
        .toggleClass("rw-seeking", MT.seeking)
        .text("seek")
        .click(seekToggle)
        .appendTo(outer);
    }
    $("<a id=rw-forw>")
      .attr("title", "<ctrl-period> forward or random")
      .text("forw")
      .click(goForward)
      .appendTo(outer);
    updateLabel();
  });

  // ctrl-comma doesn't generate keypress events
  $(document).on("keydown", ev => {
    if (!ev.ctrlKey) return;
    const focus = document.activeElement;
    const tag = focus != null ? focus.tagName : "";
    if (/^(textarea|input|select)$/i.test(tag)) return;
    if (ev.key === ",") return goBack();
    if (ev.key === ".") return goForward();
    if (ev.key === "\\") return seekToggle();
  });

  $(document).on("click", ev => {
    if (!MT.seeking && ev.target && ev.target.tagName !== "A") {
      const chosen = $("#passages .random-walk-chosen");
      if (chosen.length) {
        chosen.removeClass("random-walk-chosen");
        ignoreFuture = true;
        updateLabel();
      }
    }
  });

  $(document).on(":passagestart", () => {
    updateLabel();
  });
}

initRandomWalk();
<</script>>
