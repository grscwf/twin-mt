:: g0init Nero Constraints [inclusion] {"position":"600,2350","size":"100,100"}
<<script>>

// - Flags are booleans where null or undefined is equivalent to false.
// - "implies" are constraints on other vars when the flag is true.
//   - The constraints can be any type of value, not just flags.
const flags = {
  // true if Ivex has smashed Nero's balls
  n1_abused: {
    implies: {
      // no constraints
    },
  },

  // true if lust candle is now compulsive
  n1_candleHorny: {
    implies: {
      n1_candleLit: true,
      n1_naked: true,
      n2_extraHorny: false,
      n2_free: false,
      n2_tooClever: false,
      t_ivexReceptive: false,
    },
  },

  // true if lust candle is lit (and ivex is masked)
  n1_candleLit: {
    implies: {
      t_ivexReceptive: false,
      n2_extraHorny: false,
      n2_free: false,
      n2_tooClever: false,
      n2_paintingLanced: false,
      n2_wandExploded: false,
      n2_windowBroken: false,
    },
  },

  n1_gravAsked: {
    implies: {
      n1_gravViewed: true,
    }
  },
  n1_gravViewed: {
    implies: {
      n1_gravNoticed: true,
    }
  },

  // true if Nero can see magic
  n1_mageSight: {
    implies: {
      n1_naked: true,
      n2_deskBurned: false,
      n2_extraHorny: false,
      n2_mirrorBroken: false,
    },
  },
  n1_mirrorMagicKnown: {
    implies: {
      n1_mirrorViewed: true,
    }
  },
  n1_mirrorTapped: {
    implies: {
      n1_mageSight: true,
      n1_mirrorMagicKnown: true,
      n1_mirrorViewed: true,
      n1_mirrorWasTapped: true,
      n2_mirrorBroken: false,
    }
  },
  n1_mirrorWasTapped: {
    implies: {
      n1_mirrorMagicKnown: true,
    },
  },

  // true if Nero is naked
  n1_naked: {
    implies: {
      // no constraints
    },
  },
  n1_roomFlipped: {
    implies: {
      n1_naked: true,
    }
  },

  // true if Nero is very compliant
  n1_subby: {
    implies: {
      n1_naked: true,
    },
  },

  // true if Nero resists after being abused
  n1_tough: {
    implies: {
      n1_abused: true,
    },
  },

  n1_wandAsked: {
    implies: {
      n2_wandRanAway: false,
    },
  },
  n1_wandTouched: {
    implies: {
      n1_wandAsked: true,
    },
  },
  
  n2_bookPileBurned: {
    implies: {
      n2_bookcasesLanced: true,
      n2_wandExploded: true,
    }
  },
  n2_bookShredsBurned: {
    implies: {
      n2_booksLanced: true,
      n2_wandExploded: true,
    }
  },

  n2_bookcasesLanced: {
    implies: {
      n1_bookcasesViewed: true,
      n1_mageSight: true,
      n2_free: true,
      n2_tooClever: true,
    }
  },
  n2_booksLanced: {
    implies: {
      n1_booksViewed: true,
      n1_mageSight: true,
      n2_free: true,
      n2_tooClever: true,
    }
  },

  n2_cabinetsLanced: {
    implies: {
      n2_free: true,
      n2_tooClever: true,
    }
  },
  n2_cabinetsUnderViewed: {
    implies: {
      n1_penguinCoinDropped: true,
      n2_free: true,
    }
  },

  n2_coinsInBook: {
    implies: {
      n1_mageSight: true,
      n2_coinsInPorn: false,
      n2_coinsLanced: true,
    }
  },

  n2_coinsInPorn: {
    implies: {
      n1_mageSight: true,
      n2_coinsInBook: false,
      n2_coinsLanced: true,
    }
  },

  n2_coinsLanced: {
    implies: {
      n1_mageSight: true,
      n2_free: true,
    }
  },

  // true after easy escape
  n2_deskBurned: {
    implies: {
      n1_mageSight: false,
    },
  },

  n2_deskSearchedAgain: {
    implies: {
      n2_deskSearched: true,
    }
  },

  // true if Nero is free with a distracting amount of lust (easy escape)
  n2_extraHorny: {
    implies: {
      n1_candleHorny: false,
      n1_candleLit: false,
      n1_mageSight: false,
      n1_naked: true,
      n2_free: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
  },

  // true if Nero is free (easy or hard)
  n2_free: {
    implies: {
      n1_candleHorny: false,
      n1_candleLit: false,
      t_ivexReceptive: false,
      n1_naked: true,
      n2_ivexGone: true,
    },
  },

  // true if Ivex has left
  n2_ivexGone: {
    implies: {
      t_ivexReceptive: false,
      n1_naked: true,
    },
  },

  n2_knifeOnFloor: {
    implies: {
      // n2_free is briefly false
      n2_knifeTaken: false,
    },
  },
  n2_knifeTaken: {
    implies: {
      n1_naked: true,
      n2_free: true,
      n2_knifeOnFloor: false,
    },
  },
  n2_mapDefaced: {
    implies: {
      n1_naked: true,
      n2_free: true,
      n2_tooClever: true,
      n2_windowBroken: true,
    }
  },

  // true if the mirror is broken (easy escape)
  n2_mirrorBroken: {
    implies: {
      n1_mageSight: false,
      n1_mirrorMagicKnown: true,
      n1_mirrorTapped: false,
      n1_mirrorWasTapped: true,
      n2_mirrorTaken: false,
    },
  },

  n2_mirrorTaken: {
    implies: {
      n1_mageSight: true,
      n1_mirrorMagicKnown: true,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n2_mirrorBroken: false,
    },
  },

  n2_paintingBlasted: {
    implies: {
      n1_mageSight: true,
      n2_wandExploded: true,
      n2_windowBroken: true,
    }
  },
  n2_paintingHasBill: {
    implies: {
      n2_paintingLanced: true,
    }
  },
  n2_paintingLanced: {
    implies: {
      n1_candleLit: false,
      n1_mageSight: true,
      n2_windowBroken: true,
    }
  },

  n2_pawed: {
    implies: {
      n2_extraHorny: true,
    },
  },
  
  n2_penguinFlown: {
    implies: {
      n1_mageSight: true,
      n2_free: true,
      n2_tooClever: true,
    }
  },
  n2_penguinTorn: {
    implies: {
      n1_mageSight: true,
      n2_free: true,
      n2_tooClever: true,
    }
  },

  n2_pornLanced: {
    implies: {
      n1_booksViewed: true,
      n2_booksSearched: true,
      n2_free: true,
      n2_tooClever: true,
    }
  },

  // true if Nero did the hard escape and got extra-abused
  n2_tooClever: {
    implies: {
      n1_bottleViewed: true,
      n1_candleHorny: false,
      n1_candleLit: false,
      n1_mageSight: true,
      n1_magicPhase: MP_contact,
      n1_naked: true,
      n2_free: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
  },
  n2_wandExploded: {
    implies: {
      n1_candleLit: false,
      n1_mageSight: true,
      n2_tooClever: true,
      n2_wandTubeShot: true,
      n2_windowBroken: true,
    }
  },
  n2_wandRanAway: {
    implies: {
      n1_wandAsked: false,
      n2_wandTubeShot: false,
    },
  },
  n2_wandRefused: {
    implies: {
      n1_wandAsked: true,
    },
  },
  n2_wandUsed: {
    implies: {
      n1_wandAsked: true,
      n2_extraHorny: true,
    },
  },
  n2_wandTubeShot: {
    implies: {
      n2_tooClever: true,
      n2_wandRanAway: false,
    }
  },

  n2_windowBroken: {
    implies: {
      n1_candleLit: false,
      n1_mageSight: true,
    }
  },

  // true if Ivex is near the cross
  t_ivexNear: {
    implies: {
    },
  },

  // true if Ivex is intrigued and suggestible
  t_ivexReceptive: {
    implies: {
      n1_candleLit: false,
      n1_candleHorny: false,
      n2_extraHorny: false,
      n2_free: false,
      n2_ivexGone: false,
      n2_tooClever: false,
    },
  },

};

function checkFlags() {
  if (!setup.tester) return;
  Object.keys(flags).forEach(x => {
    // check contrapositive
    Object.keys(flags[x].implies).forEach(y => {
      if (flags[x].implies[y] === false) {
        const yf = flags[y];
        if (yf == null || yf.implies == null || yf.implies[x] !== false) {
          console.error(`flag ${x} implies !${y} is missing contrapositive`);
        }
      }
    });
  });
}

checkFlags();

const enumImplies = {
  n1_magicPhase: {
    [MP_beforeCast]: {
      n1_booksAsked: false,
      n1_magicPhaseReached: MP_beforeCast,
      n1_mirrorTapped: false,
      n1_mirrorWasTapped: false,
      n1_wandAsked: false,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_triedMagic]: {
      n1_booksAsked: false,
      n1_magicPhaseReached: MP_triedMagic,
      n1_mirrorTapped: false,
      n1_mirrorWasTapped: false,
      n1_wandAsked: false,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_wantDevice]: {
      n1_booksAsked: false,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_wantDevice,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n1_wandAsked: false,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_wantName]: {
      n1_booksAsked: false,
      n1_bottleViewed: true,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_wantName,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n1_wandAsked: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_wantTouch]: {
      n1_booksAsked: false,
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_wantTouch,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_wantPass]: {
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_wantPass,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      // can't pass wantTouch without asking about penguin
      n1_penguinAsked: true,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_onHold]: {
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_wantPass,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n1_penguinAsked: true,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_exitingHold]: {
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_wantPass,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n1_penguinAsked: true,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_contact]: {
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_contact,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n1_passIsKnown: true,
      n1_penguinAsked: true,
      n2_free: true,
      n2_ivexGone: true,
      n2_mirrorBroken: false,
      n2_tooClever: true,
    },
    [MP_lockedOut]: {
      n1_bottleViewed: true,
      n1_mageSight: true,
      n1_magicPhaseReached: MP_wantPass,
      n1_mirrorTapped: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n2_free: false,
      n2_mirrorBroken: false,
      n2_tooClever: false,
      n2_wandRanAway: false,
      n2_wandRefused: false,
      n2_wandUsed: false,
    },
    [MP_drained]: {
      n1_mageSight: false,
      n1_magicPhaseReached: MP_triedMagic,
      n1_mirrorTapped: false,
      n1_mirrorWasTapped: false,
      n1_naked: true,
      n2_extraHorny: true,
      n2_free: true,
      n2_ivexGone: true,
      n2_mirrorBroken: false,
      n2_tooClever: false,
    },
    [MP_tapLost]: {
      n1_mageSight: false,
      n1_mirrorTapped: false,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n2_extraHorny: true,
      n2_free: true,
      n2_ivexGone: true,
      n2_tooClever: false,
    },
  },

  n1_magicPhaseReached: {
    [MP_beforeCast]: {
      n1_mageSight: false,
      n1_mirrorTapped: false,
      n1_mirrorWasTapped: false,
      n2_tooClever: false,
    },
    [MP_triedMagic]: {
      n1_mirrorWasTapped: false,
      n1_naked: true,
      n2_tooClever: false,
    },
    [MP_wantDevice]: {
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n2_tooClever: false,
    },
    [MP_wantName]: {
      n1_bottleViewed: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n2_tooClever: false,
    },
    [MP_wantTouch]: {
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n2_tooClever: false,
    },
    [MP_wantPass]: {
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n1_passIsKnown: false,
      // escaped at wantPass, but pawed off, didn't try to rescue mirror,
      // didn't get contact, mirror not broken.
      n2_mirrorBroken: false,
      n2_tooClever: false,
    },
    [MP_onHold]: {
      impossible: true,
    },
    [MP_exitingHold]: {
      impossible: true,
    },
    [MP_contact]: {
      // can lose at contact: escaped at wantPass, didn't paw off,
      // tried to rescue mirror, said password, got brief contact,
      // mirror broken.
      n1_bottleNameKnown: true,
      n1_bottleViewed: true,
      n1_mirrorWasTapped: true,
      n1_naked: true,
      n1_passIsKnown: true,
      n2_free: true,
      n2_ivexGone: true,
    },
    [MP_lockedOut]: {
      impossible: true,
    },
    [MP_drained]: {
      impossible: true,
    },
    [MP_tapLost]: {
      impossible: true,
    }
  },

  // this is iffy, t_ivexContext isn't meant to be consistent outside
  // of action nodes and ask nodes.
  t_ivexContext: {
    [IC_gone]: {
      n2_ivexGone: true,
    },
    [IC_distant]: {
      t_ivexNear: false,
    },
  }

}

MT.checkState = (state, used, interactive, active) => {
  // Check flags
  for (const x of Object.keys(flags)) {

    // Ignore flag if it's been deleted
    if (active && !(x in active)) continue;

    // Check implications for true flags
    if (!state[x]) continue;
    if (used && !used.has(x)) continue;
    for (const y of Object.keys(flags[x].implies)) {
      if (used && !used.has(y)) continue;
      const val = state[y] == null ? false : state[y];
      const exp = flags[x].implies[y];
      if (val !== exp) {
        if (!interactive) return false;
        const expStr = typeof exp !== "boolean" ? `${y} === ${exp}` : exp ? y : `!${y}`;
        MT.fail(
          `${x} === ${state[x]} should imply ${expStr}; currently, ${y} === ${state[y]}`);
      }
    }
  }

  // Check enum implications
  for (const x of Object.keys(enumImplies)) {
    const xVal = state[x] == null ? "null" : state[x];
    const rules = enumImplies[x][xVal];
    if (rules == null) continue;
    if (rules.impossible) {
      if (!interactive) return false;
      const sVal = MT.enumSymbol(x, state[x]);
      MT.fail(`${x} === ${sVal} should be impossible`);
      continue;
    }
    if (used && !used.has(x)) continue;
    for (const y of Object.keys(rules)) {
      if (used && !used.has(y)) continue;
      const val = state[y] == null ? false : state[y];
      const exp = rules[y];
      if (val !== exp) {
        if (!interactive) return false;
        const expStr = typeof exp !== "boolean" ? `$[y} === ${exp}` : exp ? y : `!${y}`;
        const sVal = MT.enumSymbol(x, state[x]);
        MT.fail(
          `${x} === ${sVal} should imply ${expStr}; currently, ${y} === ${state[y]}`);
      }
    }
  }
  return true;
};

const checkConstraints = () => {
  const here = State.passage;
  if (State.current.variables.t_restarting) return true;
  if (!/^n/.test(here)) return true;
  return MT.untraced(() => {
    /* note: current (incoming) state, not active state */
    return MT.checkState(
      State.current.variables, MT.trace.wasRead, true, State.active.variables);
  });
};

$(document).on(":passageend", checkConstraints);
<</script>>
