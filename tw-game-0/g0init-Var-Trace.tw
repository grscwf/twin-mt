:: g0init Var Trace [inclusion] {"position":"550,1125","size":"100,100"}
<<script>>

MT.trace = newContext();

let _unproxied = null;
const myBrand = Symbol("VarTraceBrand");

function newContext() {
  return {
    withinInclude: false,
    wasDeleted: new Set(),
    wasRead: new Set(),
    wasSet: new Set(),
    wasTopRead: new Set(),
  };
}

Macro.add("var-trace-ignore", {
  tags: [],
  handler: function() {
    const body = this.payload[0].contents;
    MT.untraced(() => $(this.output).wiki(body));
  }
});

const origInclude = Macro.get("include");
Macro.delete("include");
Macro.add("include", {
  handler: function() {
    const save = MT.trace.withinInclude;
    MT.trace.withinInclude = true;
    try {
      origInclude.handler.call(this);
    } finally {
      MT.trace.withinInclude = save;
    }
  }
});

/** Start tracing. */
MT.traceStart = () => {
  MT.traceStop();
  MT.trace = newContext();
  _unproxied = State.active.variables;
  State.active.variables = new Proxy(_unproxied, {
    defineProperty(o, prop) {
      if (typeof prop === "string") MT.trace.wasSet.add(prop);
      return Reflect.defineProperty(...arguments);
    },
    deleteProperty(o, prop) {
      if (typeof prop === "string") MT.trace.wasDeleted.add(prop);
      return Reflect.deleteProperty(...arguments);
    },
    get(o, prop) {
      if (prop === "_varTrace") return myBrand;
      if (typeof prop === "string") {
        MT.trace.wasRead.add(prop);
        if (!MT.trace.withinInclude) MT.trace.wasTopRead.add(prop);
      }
      return Reflect.get(...arguments);
    },
    set(o, prop) {
      if (typeof prop === "string") MT.trace.wasSet.add(prop);
      return Reflect.set(...arguments);
    },
  });
};

/** Stop tracing. */
MT.traceStop = () => {
  if ((State.active.variables._varTrace || myBrand) !== myBrand) {
    throw new Error("Multiple instances of Var Trace in conflict.");
  }
  if (_unproxied != null) {
    State.active.variables = _unproxied;
    _unproxied = null;
  }
};

/** Get vname's value without tracing it. */
MT.untracedGet = vname => {
  return (_unproxied || State.active.variables)[vname];
}

/** Returns all state vars, without tracing. */
MT.untracedVars = () => {
  return _unproxied || State.active.variables;
}

/** Run fn without tracing any variables during its execution. */
MT.untraced = fn => {
  if (_unproxied == null) return fn();
  const proxy = State.active.variables;
  State.active.variables = _unproxied;
  try {
    return fn();
  } finally {
    State.active.variables = proxy;
  }
};

<</script>>
