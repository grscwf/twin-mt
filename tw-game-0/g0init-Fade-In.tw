:: g0init Fade-In [inclusion] {"position":"200,575","size":"100,100"}
<<append head>><style>
  /* <span> for each fade-in section */
  .fade-in,
  .fade-in .sprite-q {
    transition: all .4s ease-in;
  }
  .fade-in img {
    transition: all .4s ease-in;
  }

  /*
   * Hide text. Note: using opacity or filter here will make it impossible
   * to have links visible (child filter cannot override parent).
   * The :not clause gives this rule a high CSS specificity, making this
   * more likely to override complex selectors elsewhere.
   */
  .fade-in-hidden:not(#_#_#_#_#_),
  .fade-in-hidden:not(#_#_#_#_#_) * {
    background-image: unset;
    color: rgba(0, 0, 0, 0);
    pointer-events: none;
    text-decoration-color: rgba(0, 0, 0, 0);
  }

  /* Hide media. */
  .fade-in-hidden:not(#_#_#_#_#_) img,
  .fade-in-hidden:not(#_#_#_#_#_) video {
    opacity: 0;
  }

  /* actions list image */
  .fade-in-hidden:not(#_#_#_#_#_) li::before {
    background-image: unset;
  }

  /* Block-out hidden links. */
  .fade-in-hidden:not(#_#_#_#_#_) a {
    background-color: #222;
    border-radius: 4px;
    color: rgba(0, 0, 0, 0);
    pointer-events: auto;
  }
  .fade-in-hidden:not(#_#_#_#_#_) a:hover {
    background-color: #333;
    color: rgba(0, 0, 0, 0);
  }

  /* Put pulsing dots at the section that will be revealed next. */
  .fade-in-next:not(#_#_#_#_#_)::before {
    animation: 0.5s 1s ease-in-out alternate both infinite fade-in-blink;
    color: #fff;
    content: ". . .";
    cursor: pointer;
    display: inline-block;
    font-weight: bold;
    pointer-events: auto;
    position: absolute;
  }
  @keyframes fade-in-blink {
    from { opacity: 0.4; }
    to { opacity: 1; }
  }

  .fade-in-no-dots.fade-in-next:not(#_#_#_#_#_)::before {
    content: "";
  }

  .fade-in-no-pulse.fade-in-next:not(#_#_#_#_#_)::before {
    animation: none;
    opacity: 0.6;
  }

  /* Absorb clicks for a small amount of time after fade-in. */
  .fade-in-absorb:not(#_#_#_#_#_),
  .fade-in-absorb:not(#_#_#_#_#_) *,
  .fade-in-absorb:not(#_#_#_#_#_) *:hover {
    cursor: wait;
  }
  .fade-in-absorb:not(#_#_#_#_#_) a,
  .fade-in-absorb:not(#_#_#_#_#_) a:hover {
    color: rgb(100, 100, 100, 1);
  }
</style><</append>>

<<script>>
/*
 * Sometimes a player will click with intent to skip, but fade-in will
 * happen almost at the same time, and the click will land after the
 * fade-in happens. This is annoying if the click lands on a link and
 * follows it. So we absorb clicks a small amount of time after
 * automatic fade-in.
 */
const absorbMsec = 500;

/**
 * This description assumes you're using the default style.
 *
 * <<fade-in 1.5s [no-dots | no-pulse | click-anywhere]>>
 *    - Normally, a pulsing "..." appears here.
 *    - After 1.5 seconds, this section's text fades in.
 *    - Click on the "..." will skip the delay.
 *    - Links in this section are shown without delay, but blocked out with
 *      a gray rectangle.
 *    - Clicking on a blocked-out link will also skip the delay.
 *    - "no-dots" means don't show the dots.
 *    - "no-pulse" means show the dots, but don't pulse them.
 *    - "click-anywhere" means clicking anywhere will skip the delay.
 * <<fade-next 2s>>
 *    - After the first section has faded-in, the "..." appears here.
 *    - After another 2s, this section's text fades in.
 *    - There can be any number of "fade-next" sections.
 * <</fade-in>>
 */
Macro.add("fade-in", {
  tags: ["fade-next"],
  handler: function() {
    const noDots = this.args.includes("no-dots");
    const noPulse = this.args.includes("no-pulse");
    const clickAnywhere = this.args.includes("click-anywhere");

    const queue = [];
    let timeout = null;
    let absorbing = false;

    const skipAll = ev => {
      // note, this assumes passage only has one fade-in
      const absorb = $("#story .fade-in-absorb");
      if (absorb.length) {
        ev.stopPropagation();
        ev.preventDefault();
        return;
      }

      const hidden = $("#story .fade-in-hidden");
      if (!hidden.length) {
        $("#story")[0].removeEventListener("click", skipAll, true);
        return;
      }

      hidden.removeClass("fade-in-hidden fade-in-next");
      hidden.addClass("fade-in-absorb");
      setTimeout(() => {
        hidden.removeClass("fade-in-absorb");
        $("#story")[0].removeEventListener("click", skipAll, true);
      }, absorbMsec);
      queue.length = 0;
    };

    if (clickAnywhere) {
      $("#story")[0].addEventListener("click", skipAll, true);
    }

    const next = () => {
      if (timeout != null) clearTimeout(timeout);
      if (queue.length === 0) return;
      const [delay, span] = queue[0];
      span.addClass("fade-in-next");
      timeout = setTimeout(() => {
        if (span.hasClass("fade-in-hidden")) {
          span.addClass("fade-in-absorb");
          setTimeout(() => span.removeClass("fade-in-absorb"), absorbMsec);
        }
        span.removeClass("fade-in-hidden fade-in-next");
        if (queue.length && queue[0][1] === span) {
          queue.shift();
          next();
        }
      }, delay);
    };

    const skipTo = jq => {
      const pos = queue.findIndex(q => q[1] === jq);
      if (pos < 0) return;
      for (let i = 0; i <= pos; i++) {
        const span = queue.shift()[1];
        span.removeClass("fade-in-hidden fade-in-next");
      }
      next();
    };

    const T = State.temporary;

    for (let i = 0; i < this.payload.length; i++) {
      const section = this.payload[i];
      let delay = Util.fromCssTime(section.args[0]);
      delay = Math.max(delay, Engine.minDomActionDelay);
      if (MT.roaming || T.isTranscript) delay = 0;
      const span = $("<span>")
        .addClass("fade-in fade-in-hidden")
        .toggleClass("fade-in-no-dots", noDots)
        .toggleClass("fade-in-no-pulse", noPulse)
        .wiki(section.contents)
        .appendTo(this.output);

      if (T.isTranscript) {
        if (i < this.payload.length - 1) {
          span.find("br:last-child").replaceWith("<hr class=time-sep>");
        }
      }

      const hurry = ev => {
        if (span.hasClass("fade-in-absorb")) {
          ev.preventDefault();
          ev.stopPropagation();
        } else if (span.hasClass("fade-in-hidden")) {
          ev.preventDefault();
          ev.stopPropagation();
          span.removeClass("fade-in-hidden fade-in-next");
          span.addClass("fade-in-absorb");
          setTimeout(() => {
            span.removeClass("fade-in-absorb");
            span[0].removeEventListener("click", hurry, true);
          }, absorbMsec);
          skipTo(span);
        } else {
          span[0].removeEventListener("click", hurry, true);
        }
      };
      span[0].addEventListener("click", hurry, true);
      queue.push([delay, span]);
    }

    setTimeout(next);
  }
});
<</script>>
