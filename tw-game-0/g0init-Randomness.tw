:: g0init Randomness [inclusion] {"position":"450,850","size":"100,100"}
<<script>>
/*
 * This is a deterministic RNG that keeps its state in $g_rand,
 * so it can be replayed for the History page.
 * 
 * (SugarCube has a deterministic RNG option, but it uses hidden state
 * that can't be replayed easily.)
 */

/** Returns x rotated left by k bits. */
function rotl(x, k) {
  return (x << k) | (x >>> (32 - k));
}

/**
 * Returns a random uint32. Uses and updates state, which should be
 * a nonzero [int32, int32] pair. The algorithm is "xoroshiro64**".
 */
MT.randNext = state => {
  const s0 = state[0];
  let s1 = state[1];
  const result = rotl(s0 * 0x9e3779bb, 5) * 5;
  s1 ^= s0;
  state[0] = rotl(s0, 26) ^ s1 ^ (s1 << 9);
  state[1] = rotl(s1, 13);
  return result >>> 0;
};

/** Returns a new random state. */
MT.randCreate = () => {
  const state = [1, 0 | (Math.random() * 0xffffffff)];
  MT.randNext(state);
  MT.randNext(state);
  return state;
};

/** Returns a random int in [0, n). Uses and updates $g_rand */
MT.randInt = (n) => {
  let state = State.variables.g_rand;
  if (state == null) {
    MT.warn("g_rand was not set");
    state = MT.randCreate();
  }
  state = [state[0], state[1]];
  const r = MT.randNext(state);
  State.variables.g_rand = state;
  return r % n;
};

/** Initializes $g_rand to a new state. */
MT.randReset = () => {
  State.variables.g_rand = MT.randCreate();
};

/** Returns a random item from list (which can be a Set). */
MT.pick = list => {
  if (list instanceof Set) list = Array.from(list);
  const n = MT.randInt(list.length);
  return list[n];
};

<</script>>
