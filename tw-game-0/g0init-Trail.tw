:: g0init Trail [inclusion] {"position":"450,950","size":"100,100"}
<<script>>

const sectInfo = {
  n0a: {
    use: "n9a",
  },
  n1a: {
    alwaysShow: true,
    preamble: "Nero First Floor",
    title: "Beginning",
  },
  n1cn: {
    title: "Sparring",
  },
  n1cr: {
    title: "Charming",
  },
  n1cs: {
    title: "Yielding",
  },
  n1cx: {
    use: "n1d",
  },
  n1d: {
    title: "The Candle",
  },
  n1e: {
    use: "n1d",
  },
  n1f: {
    title: "The Globe",
  },
  n1p: {
    title: "The Cock",
  },
  n1s: {
    title: "The Magic",
  },
  n1x: {
    title: "The Objects",
  },
  n1y: {
    use: "n1x",
  },
  n2a: {
    title: "Alone",
  },
  n2b: {
    use: "n2a",
  },
  n2c: {
    use: "n2a",
  },
  n2f: {
    title: "Free",
  },
  n2x: {
    title: "Free Objects",
  },
  n9a: {
    title: "Endings",
  },
};

MT.trailMaxEvents = 1000;
MT.trailMaxFirst = 1000;

/** Record of passage title -> info */
const passageInfo = {};

/** Ordered list of section names */
const sectNames = [];

/** Record of section name -> array of titles */
const sections = {};

/** expose state for easier debugging */
MT.trail = { passageInfo, sectNames, sections }

function gatherPassages() {
  const all = Story.lookup();
  for (const p of all) {
    if (p.tags.includes("inclusion")) continue;
    if (p.tags.includes("is-menu")) continue;
    if (p.tags.includes("mt-sketch")) continue;

    const m = /^[n]\d\w*\b/.exec(p.title);
    if (m == null) continue;

    let sect = m[0];
    if (sectInfo[sect] == null) {
      MT.diag(`Warning: no sectInfo for ${sect}`);
    }
    if (sectInfo[sect].use != null) {
      sect = sectInfo[sect].use;
    }

    sections[sect] ||= [];
    sections[sect].push(p.title);

    passageInfo[p.title] = { };
  }

  sectNames.push(... Object.keys(sections).sort());

  for (const titles of Object.values(sections)) {
    titles.sort();
  }
}

function compact(trail) {
  const over = trail.events.length - MT.trailMaxEvents;
  if (over > 0) {
    const room = trail.first.length - MT.trailMaxFirst;
    if (room > 0) {
      const save = trail.events.slice(0, Math.min(room, over));
      trail.first.push(...save);
    }
    trail.events.splice(0, over);
    trail.recent -= over;
  }
}

MT.trailGet = () => {
  let trail = MT.mdGetUncached("mg_trail");
  trail ??= {};
  trail.recent ??= 0;
  trail.events ??= [];
  trail.first ??= [];
  return trail;
};

MT.trailAddNow = () => {
  if (MT.roaming) return;
  if (MT.untracedGet("g_mutated")) return;
  const trail = MT.trailGet();
  const n = trail.events.length;
  if (n > 0 && trail.events[n - 1].turn === State.turns) return;
  const event = {
    tab: MT.getTabId(),
    time: new Date().toISOString(),
    turn: State.turns,
    title: State.passage,
  };
  if (MT.trace.wasRead.size > 0) {
    event.state = {};
    // Note: current (incoming) state, not active state.
    const CV = State.current.variables;
    let anySet = false;
    for (const vn of MT.trace.wasRead) {
      if (CV[vn] != null) {
        event.state[vn] = CV[vn];
        anySet = true;
      }
    }
    if (!anySet) delete event.state;
  }
  trail.events.push(event);
  compact(trail);
  MT.mdSet("mg_trail", trail);
};

MT.trailAddOther = event => {
  const trail = MT.trailGet();
  trail.events.push({
    tab: MT.getTabId(),
    time: new Date().toISOString(),
    ...event
  });
  compact(trail);
  MT.mdSet("mg_trail", trail);
};

MT.trailClearRecent = () => {
  const trail = MT.trailGet();
  trail.recent = trail.events.length;
  MT.mdSet("mg_trail", trail);
};

MT.trailForgetOlder = () => {
  const trail = MT.trailGet();
  trail.events.splice(0, trail.recent);
  trail.first = [];
  trail.recent = 0;
  MT.mdSet("mg_trail", trail);
};

function renderSeen(title, state, out) {
  out.empty();
  const div = MT.tranRenderOne(title, state);
  if (setup.debug) {
    const plain = MT.tranRenderOne(title, null);
    const clue = makeClue(plain);
    clue.wiki("?debugIcon <hr>").appendTo(out);
    $("<div class=trail-info-title>")
      .wiki(`?debugIcon ${title}`)
      .appendTo(out);
  }
  out.append(div);
  if (setup.debug) {
    $("<div class=trail-info-state>")
      .text(JSON.stringify(state || {}, null, " "))
      .appendTo(out);
  }
}

function renderUnseen(title, out) {
  out.empty();
  const div = MT.tranRenderOne(title, null);
  const clue = makeClue(div);
  out.append(clue);

  if (setup.debug) {
    $("<div class=trail-info-debug>")
      .append("<hr>")
      .append($("<div class=trail-info-title>").text(`\ud83d\udd27 ${title}`))
      .append(div)
      .appendTo(out);
  }
}

function makeClue(div) {
  const hasCut = div.find("#clue-cut").length !== 0;
  let wordsLeft = hasCut ? 100 : 10;
  const trim = node => {
    if (wordsLeft <= 0) {
      node.parentNode.removeChild(node);

    } else if (node.nodeType === 3 /* text */) {
      const words = node.nodeValue.split(/\s+/);
      let n = words.length;
      if (n > 0 && words[n - 1] === "") n -= 1;
      if (n > 0 && words[0] === "") n -= 1;
      if (n === 0) return;
      if (n > wordsLeft) {
        if (words[0] === "") wordsLeft += 1;
        const phrase = words.slice(0, wordsLeft).join(" ");
        const textNode = document.createTextNode(phrase);
        node.parentNode.replaceChild(textNode, node);
      }
      wordsLeft -= n;

    } else if (node.nodeType === 1 /* element*/) {
      if (node.tagName === "B" && node.getAttribute("id") === "clue-cut") {
        wordsLeft = 0;
      } else if (/^(BR|HR)/.test(node.tagName)) {
        node.parentNode.removeChild(node);
      } else if (/^(STYLE)$/.test(node.tagName)) {
        return;
      } else {
        const kids = Array.from(node.childNodes);
        kids.forEach(kid => trim(kid));
      }

    } else {
      node.parentNode.removeChild(node);
    }
  };
  const copy = div.clone();
  copy.find("meta-text").remove();
  copy.find(".clue-remove").remove();
  trim(copy[0]);
  copy.addClass("trail-info-unseen");
  copy.append("...");
  return copy;
}

MT.trailRender = (out) => {
  const current = new Set(State.history.map(m => m.title));
  const recent = new Set();
  const older = new Set();

  const trail = MT.trailGet();
  for (let i = 0, n = trail.events.length; i < n; i++) {
    const ev = trail.events[i];
    if (ev.title == null) continue;
    if (current.has(ev.title)) continue;
    if (i < trail.recent) {
      older.add(ev.title)
    } else {
      older.delete(ev.title);
      recent.add(ev.title);
    }
  }
  for (const ev of trail.first) {
    if (ev.title == null) continue;
    older.add(ev.title);
  }

  const renderInfo = (title, out) => {
    if (current.has(title)) {
      const moment = State.history.findLast(m => m.title === title);
      renderSeen(title, moment.variables, out);

    } else if (recent.has(title) || older.has(title)) {
      const event = trail.events.findLast(ev => ev.title === title) ||
        trail.first.findLast(ev => ev.title === title);
      renderSeen(title, event.state, out);

    } else {
      renderUnseen(title, out);
    }
  };

  const onClick = ev => {
    const target = $(ev.target);
    let info = $("#trail-info");

    if (target.hasClass("trail-selected")) {
      target.removeClass("trail-selected");
      info.remove();
      return;
    }

    $(".trail-selected").removeClass("trail-selected");
    target.addClass("trail-selected");

    if (info.length === 0) {
      info = $("<div id=trail-info>");
    }
    info.appendTo(target.parent());

    const title = target.attr("data-title");
    renderInfo(title, info);
  };

  let hasRecent = false;
  let hasOlder = false;
  for (const sect of sectNames) {
    if (sectInfo[sect].preamble) {
      $(`<div class=trail-preamble>`)
        .text(sectInfo[sect].preamble)
        .appendTo(out);
    }
    const group = $(`<div class=trail-group>`).appendTo(out);
    const groupTitle = $(`<div class=trail-group-title>`)
      .appendTo(group);
    let anyKnown = false;
    for (const title of sections[sect]) {
      const item = $(`<div class=trail-item>`)
        .toggleClass("trail-current", current.has(title))
        .toggleClass("trail-recent", recent.has(title))
        .toggleClass("trail-older", older.has(title))
        .appendTo(group);
      if (setup.debug) {
        item.attr("title", title);
      }
      item.attr("data-title", title);
      item.on("click", onClick);

      hasRecent ||= recent.has(title);
      hasOlder ||= older.has(title);
      anyKnown ||= current.has(title) || recent.has(title) || older.has(title);
    }
    if (anyKnown || sectInfo[sect].alwaysShow) {
      groupTitle.text(sectInfo[sect].title)
        .addClass("trail-group-title-known");
    } else if (setup.debug) {
      groupTitle.text(sectInfo[sect].title).wiki("?debugIcon")
        .addClass("trail-group-title-debug");
    } else if (false) {
      groupTitle.text(sectInfo[sect].title.replace(/./g, "?"))
        .addClass("trail-group-title-unknown");
    } else {
      group.remove();
    }
  }

  if (hasRecent) {
    $("#trail-clear-recent")
      .prop("disabled", false)
      .on("click", () => {
        Dialog.setup("Confirm Clear Recent");
        Dialog.wiki(`<<nobr>>
          This will remove the "recent" marks.
          The pages will become marked as "older".
          ?P
          <<button "Clear Recent">>
            <<run
              Dialog.close();
              MT.trailClearRecent();
              MT.revisitHere();
            >>
          <</button>>
          <</nobr>>
        `);
        Dialog.open();
      });
  }
  if (hasRecent || hasOlder) {
    $("#trail-forget-older")
      .prop("disabled", false)
      .on("click", () => {
        Dialog.setup("Confirm Forget Older");
        Dialog.wiki(`<<nobr>>
          This will delete the record of older playthroughs.
          ?P
          <<button "Forget Older">>
            <<run
              Dialog.close();
              MT.trailForgetOlder();
              MT.revisitHere();
            >>
          <</button>>
          <</nobr>>
        `);
        Dialog.open();
      });
  }
};

function trailInit() {
  MT.mdDefIgnored("mg_trail");

  if (!setup.playtest) return;
  gatherPassages();
  $(document).on(":passageend", MT.trailAddNow);
}

trailInit();

<</script>>
