:: g0init Trail [inclusion] {"position":"675,1100","size":"100,100"}
<<script>>

const sectInfo = {
  n0a: {
    use: "n9a",
  },
  n1a: {
    alwaysShow: true,
    preamble: "Nero First Floor",
    title: "Beginning",
  },
  n1cn: {
    title: "Sparring",
  },
  n1cr: {
    title: "Charming",
  },
  n1cs: {
    title: "Yielding",
  },
  n1cx: {
    use: "n1d",
  },
  n1d: {
    title: "The Candle",
  },
  n1e: {
    use: "n1d",
  },
  n1f: {
    title: "The Globe",
  },
  n1p: {
    title: "The Cock",
  },
  n1s: {
    title: "The Magic",
  },
  n1x: {
    title: "The Objects",
  },
  n1y: {
    use: "n1x",
  },
  n2a: {
    title: "Alone",
  },
  n2b: {
    use: "n2a",
  },
  n2c: {
    use: "n2a",
  },
  n2f: {
    title: "Free",
  },
  n2x: {
    use: "n1x",
  },
  n9a: {
    title: "Endings",
  },
};

/** Record of passage title -> info */
const passageInfo = {};

/** Ordered list of section names */
const sectNames = [];

/** Record of section name -> array of titles */
const sections = {};

/** expose state for easier debugging */
MT.trail = { passageInfo, sectNames, sections }

function gatherPassages() {
  const all = Story.lookup();
  for (const p of all) {
    if (p.tags.includes("inclusion")) continue;
    if (p.tags.includes("is-menu")) continue;
    if (p.tags.includes("mt-sketch")) continue;

    const m = /^[n]\d\w*\b/.exec(p.title);
    if (m == null) continue;

    let sect = m[0];
    if (sectInfo[sect] == null) {
      MT.diag(`Warning: no sectInfo for ${sect}`);
    }
    if (sectInfo[sect].use != null) {
      sect = sectInfo[sect].use;
    }

    sections[sect] ||= [];
    sections[sect].push(p.title);

    passageInfo[p.title] = { };
  }

  sectNames.push(... Object.keys(sections).sort());

  for (const titles of Object.values(sections)) {
    titles.sort();
  }
}

MT.trailGet = () => {
  let trail = MT.mdGetUncached("mg_trail");
  trail ??= {
    recent: 0,
    events: [],
  };
  return trail;
}

MT.trailAddNow = () => {
  if (MT.roaming) return;
  if (MT.untracedGet("g_mutated")) return;
  const trail = MT.trailGet();
  const n = trail.events.length;
  if (n > 0 && trail.events[n - 1].turn === State.turns) return;
  const event = {
    tab: MT.getTabId(),
    title: State.passage,
    turn: State.turns,
  };
  if (MT.trace.wasRead.size > 0) {
    event.state = {};
    // Note: current (incoming) state, not active state.
    const CV = State.current.variables;
    let anySet = false;
    for (const vn of MT.trace.wasRead) {
      if (CV[vn] != null) {
        event.state[vn] = CV[vn];
        anySet = true;
      }
    }
    if (!anySet) delete event.state;
  }
  trail.events.push(event);
  MT.mdSet("mg_trail", trail);
};

MT.trailAddOther = ev => {
  const trail = MT.trailGet();
  trail.events.push(ev);
  MT.mdSet("mg_trail", trail);
};

MT.trailClearRecent = () => {
  const trail = MT.trailGet();
  trail.recent = trail.events.length;
  MT.mdSet("mg_trail", trail);
};

MT.trailForgetOlder = () => {
  const trail = MT.trailGet();
  trail.events.splice(0, trail.recent);
  trail.recent = 0;
  MT.mdSet("mg_trail", trail);
};

MT.trailRender = (out) => {
  const current = new Set(State.history.map(m => m.title));
  const recent = new Set();
  const older = new Set();

  const trail = MT.trailGet();
  for (let i = 0, n = trail.events.length; i < n; i++) {
    const ev = trail.events[i];
    if (ev.title == null) continue;
    if (current.has(ev.title)) continue;
    if (i < trail.recent) {
      older.add(ev.title)
    } else {
      older.delete(ev.title);
      recent.add(ev.title);
    }
  }

  let hasRecent = false;
  let hasOlder = false;
  for (const sect of sectNames) {
    if (sectInfo[sect].preamble) {
      $(`<div class=trail-preamble>`)
        .text(sectInfo[sect].preamble)
        .appendTo(out);
    }
    const group = $(`<div class=trail-group>`).appendTo(out);
    const groupTitle = $(`<div class=trail-group-title>`)
      .appendTo(group);
    let anyKnown = false;
    for (const title of sections[sect]) {
      const item = $(`<div class=trail-item>`)
        .toggleClass("trail-current", current.has(title))
        .toggleClass("trail-recent", recent.has(title))
        .toggleClass("trail-older", older.has(title))
        .appendTo(group);
      if (setup.debug) {
        item.attr("title", title);
      }
      hasRecent ||= recent.has(title);
      hasOlder ||= older.has(title);
      anyKnown ||= current.has(title) || recent.has(title) || older.has(title);
    }
    if (anyKnown || sectInfo[sect].alwaysShow) {
      groupTitle.text(sectInfo[sect].title)
        .addClass("trail-group-title-known");
    } else if (false) {
      groupTitle.text(sectInfo[sect].title.replace(/./g, "?"))
        .addClass("trail-group-title-unknown");
    } else {
      group.remove();
    }
  }

  if (hasRecent) {
    $("#trail-clear-recent")
      .prop("disabled", false)
      .on("click", () => {
        Dialog.setup("Confirm Clear Recent");
        Dialog.wiki(`<<nobr>>
          This will remove the "recent" marks.
          The pages will become marked as "older".
          ?P
          <<button "Clear Recent">>
            <<run
              Dialog.close();
              MT.trailClearRecent();
              MT.revisitHere();
            >>
          <</button>>
          <</nobr>>
        `);
        Dialog.open();
      });
  }
  if (hasRecent || hasOlder) {
    $("#trail-forget-older")
      .prop("disabled", false)
      .on("click", () => {
        Dialog.setup("Confirm Forget Older");
        Dialog.wiki(`<<nobr>>
          This will delete the record of older playthroughs.
          ?P
          <<button "Forget Older">>
            <<run
              Dialog.close();
              MT.trailForgetOlder();
              MT.revisitHere();
            >>
          <</button>>
          <</nobr>>
        `);
        Dialog.open();
      });
  }
};

function trailInit() {
  if (!setup.playtest) return;
  MT.mdDefIgnored("mg_trail");
  gatherPassages();
  $(document).on(":passageend", MT.trailAddNow);
}

trailInit();

<</script>>