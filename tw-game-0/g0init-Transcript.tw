:: g0init Transcript [inclusion] {"position":"250,725","size":"100,100"}
<<append head>><style>

#tran-outer a {
  color: #aac;
  cursor: text;
}
#tran-outer#tran-outer a.tran-next {
  color: #6ef;
}

#tran-outer ul.actions li::before {
  filter: saturate(0);
}

#tran-outer hr {
  border-color: #333;
}

#tran-outer .random-walk-chosen {
  outline: none;
}

.tran-entry {
  position: relative;
}

.tran-title {
  background-color: #111;
  border: 1px solid #333;
  border-radius: 4px;
  color: #666;
  font-size: 10px;
  padding: 0 4px;
  position: absolute;
  right: 0;
  top: -26px;
}

.tran-elided {
  margin-left: .2em;
}

.tran-fade-in:not(#_#_#_#_) {
  margin-left: 30%;
  width: 40%;
}

</style><</append>>

<<script>>

function cleanHtml(jq, nextTitle, nextCode) {
  jq.removeClass("passage-in");
  jq.find(".random-walk-chosen").removeClass("random-walk-chosen");
  jq.find(".fade-in-hidden").removeClass("fade-in-hidden");
  jq.find(".fade-in-absorb").removeClass("fade-in-absorb");
  jq.find(".tame-hide").removeClass("tame-hide");
  jq.find(".tran-remove").remove();
  jq.find("[data-name=silently]").remove();
  jq.find(".patience-debug").remove();
  jq.find(".ro-debug").remove();
  jq.find(".debug").replaceWith(function() { return $(this).contents(); });

  // highlight the link followed.
  if (nextTitle != null) {
    let link = jq.find(`a[data-passage="${nextTitle}"]`);
    if (link.length > 1 && nextCode != null) {
      link = link.filter(`[data-mta-code="${nextCode}"]`);
    }
    link.addClass("tran-next");

    // remove tran-cut
    const cut = jq.find(".tran-cut");
    cut.each((i, el) => {
      if ($(el).attr("data-passage") === nextTitle) {
        while (el.parentNode != null && !el.classList.contains("tran-entry")) {
          while (el.nextSibling != null) {
            el.nextSibling.remove();
          }
          el = el.parentNode;
        }
        $(el).append(
          `<span class="tran-elided">&hellip;</span>`);
      }
    });
  }

  // fade-in separators
  const fb1 = jq.find(".fade-in").prev("br");
  fb1.replaceWith("<hr class=tran-fade-in>");
  const fb2 = jq.find(".fade-in br:last-child");
  fb2.replaceWith("<hr class=tran-fade-in>");

  // glitch link
  const gl = jq.find(".glitch-link");
  if (gl.length) {
    const clicked = gl.find("a.tran-next");
    if (clicked.length) {
      gl.removeClass("glitch-link");
    } else {
      gl.remove();
    }
  }

  // glitch text
  const gh = jq.find(".glitch-hidden");
  gh.addClass("glitch-fading-out");
  gh.removeClass("glitch-hidden");
  jq.find("#tame-1 a").remove();

  // remove trailing space and Continue/Return links
  const shouldRemove = el => {
    if (el.nodeName === "BR") return true;
    if (el.nodeName === "#text" && el.nodeValue.trim() === "") return true;
    if (el.nodeName === "A") {
      if (/^\s*(Continue|Return)\s*$/.test(el.textContent)) return true;
    }
    return false;
  };
  let el = jq[0];
  while (el != null && el.lastChild != null) {
    while (el.lastChild != null && shouldRemove(el.lastChild)) {
      el.lastChild.remove();
    }
    el = el.lastChild;
  }
}

MT.tranRender = output => {
  const outer = $("<div id=tran-outer>").appendTo(output);

  const hist = MT.getHistory();
  let turn = 0;

  const renderSome = () => {
    const batch = 10;
    const stop = Math.min(turn + batch, hist.length);

    const savedVars = State.active.variables;
    const savedTemp = Object.entries(State.temporary);
    try {
      for (; turn < stop; turn++) {
        const moment = hist[turn];

        if (turn !== 0) {
          $("<hr class=text-sep>").appendTo(outer);
        }

        let nextTitle = null;
        let nextCode = null;
        if (turn + 1 < hist.length) {
          nextTitle = hist[turn + 1].title;
          const V = hist[turn + 1].variables;
          if (V.g_mtaCodeTurn === turn + 1) {
            nextCode = V.g_mtaCode;
          }
        }

        const text = Story.get(moment.title).text;
        State.active.variables = clone(moment.variables);
        State.clearTemporary();
        State.temporary.isTranscript = true;
        State.temporary.tranPassage = moment.title;

        let div = $("<div class=tran-entry>");

        if (setup.tester) {
          $("<div class=tran-title>").text(moment.title)
            .appendTo(div);
        }

        MT.suppressErrors(() => {
          div.wiki(text);
        });
        // clone to remove event handlers
        div = div.clone();

        cleanHtml(div, nextTitle, nextCode);
        $(outer).append(div);
      }
    } finally {
      State.active.variables = savedVars;
      State.clearTemporary();
      for (const [k, v] of savedTemp) {
        State.temporary[k] = v;
      }
    }
  };

  const renderLoop = () => {
    renderSome();
    if (turn < hist.length) {
      setTimeout(renderLoop);
    } else {
      const words = MT.countWords($(outer).text());
      const passages = hist.length;
    }
  };
  
  renderLoop();
}

/**
 * <<tran-cut [[link]]>>
 * <<tran-cut text link>>
 * 
 * Emit link. In the transcript, if the player followed this link,
 * elide everything after this link in the passage.
 */
Macro.add("tran-cut", {
  handler: function() {
    const frag = document.createDocumentFragment();
    if (this.args.length === 1) {
      $(frag).wiki(this.args.raw);
    } else {
      $(frag).wiki(`<<link ${this.args.raw}>><</link>>`);
    }
    $(frag).find("a").addClass("tran-cut");
    $(this.output).append(frag);
  }
});

<</script>>
