:: g0init Transcript [inclusion] {"position":"575,950","size":"100,100"}
<<append head>><style>

#tran-outer a {
  color: #aac;
  cursor: text;
}
#tran-outer#tran-outer a.tran-next {
  color: #6ef;
}

#tran-outer ul.actions li::before {
  filter: saturate(0);
}

#tran-outer hr {
  border-color: #555;
}

#tran-outer .random-walk-chosen {
  outline: none;
}

.tran-entry {
  position: relative;
}

.tran-title {
  background-color: #111;
  border: 1px solid #333;
  border-radius: 4px;
  color: #666;
  font-size: 10px;
  padding: 0 4px;
  position: absolute;
  right: 0;
  top: -26px;
}
.tran-title:hover {
  background-color: #666;
  color: #111;
}
.tran-title.tran-clickable {
  cursor: pointer;
}

.tran-elided {
  margin-left: .2em;
}

</style><</append>>

<<script>>

function cleanHtml(jq, nextTitle, nextCode) {
  jq.removeClass("passage-in");
  jq.find(".random-walk-chosen").removeClass("random-walk-chosen");
  jq.find(".fade-in-hidden").removeClass("fade-in-hidden");
  jq.find(".fade-in-absorb").removeClass("fade-in-absorb");
  jq.find(".tame-hide").removeClass("tame-hide");
  jq.find(".tran-remove").remove();
  jq.find("[data-name=silently]").remove();
  jq.find(".patience-debug").remove();
  jq.find(".ro-debug").remove();
  jq.find(".debug").replaceWith(function() { return $(this).contents(); });

  // highlight the link followed.
  if (nextTitle != null) {
    let link = jq.find(`a[data-passage="${nextTitle}"]`);
    if (link.length > 1 && nextCode != null) {
      link = link.filter(`[data-mta-code="${nextCode}"]`);
    }
    link.addClass("tran-next");

    // remove tran-cut
    const cut = jq.find(".tran-cut");
    cut.each((i, el) => {
      if ($(el).attr("data-passage") === nextTitle) {
        while (el.parentNode != null && !el.classList.contains("tran-entry")) {
          while (el.nextSibling != null) {
            el.nextSibling.remove();
          }
          el = el.parentNode;
        }
        $(el).append(
          `<span class="tran-elided">&hellip;</span>`);
      }
    });
  }

  // remove tran-cut-span
  jq.find(".tran-cut-span").each((i, el) => {
    if ($(el).find(".tran-next").length) {
      while (el.parentNode != null && !el.classList.contains("tran-entry")) {
        while (el.nextSibling != null) {
          el.nextSibling.remove();
        }
        el = el.parentNode;
      }
      $(el).append(
        `<span class="tran-elided">&hellip;</span>`);
    }
  });

  // add an hr before any fade-in that has a paragraph before
  const fb1 = jq.find(".fade-in").prev("br");
  fb1.replaceWith("<hr class=time-sep>");

  // glitch link
  const gl = jq.find(".glitch-link");
  if (gl.length) {
    const clicked = gl.find("a.tran-next");
    if (clicked.length) {
      gl.removeClass("glitch-link");
    } else {
      gl.remove();
    }
  }

  // glitch text
  const gh = jq.find(".mt-hidden");
  gh.addClass("glitch-fading-out");
  gh.removeClass("mt-hidden");
  jq.find("#tame-1 a").remove();

  // remove trailing space and Continue/Return links
  const shouldRemove = el => {
    if (el.nodeName === "BR") return true;
    if (el.nodeName === "#text" && el.nodeValue.trim() === "") return true;
    if (el.nodeName === "A") {
      if (/^\s*(Continue|Return)\s*$/.test(el.textContent)) return true;
    }
    return false;
  };
  let el = jq[0];
  while (el != null && el.lastChild != null) {
    while (el.lastChild != null && shouldRemove(el.lastChild)) {
      el.lastChild.remove();
    }
    el = el.lastChild;
  }
}

function tranRenderInternal(title, state, turn, next) {
  const text = Story.get(title).text;
  State.active.variables = clone(state) || {};
  MT.enumInit();
  State.clearTemporary();
  State.temporary.isTranscript = true;
  State.temporary.tranPassage = title;
  State.temporary.tranTurn = turn;

  let div = $("<div class=tran-entry>");
  MT.suppressErrors(() => {
    div.wiki(text);
  });
  // clone to remove event handlers
  div = div.clone();
  cleanHtml(div, next.title, next.code);

  return div;
}

MT.tranRenderOne = (title, state) => {
  const savedVars = State.active.variables;
  const savedTemp = Object.entries(State.temporary);
  try {
    return tranRenderInternal(title, state, 0, {});
  } finally {
    State.active.variables = savedVars;
    State.clearTemporary();
    for (const [k, v] of savedTemp) {
      State.temporary[k] = v;
    }
  }
};

MT.tranRender = output => {
  const outer = $("<div id=tran-outer>").appendTo(output);

  const hist = MT.getHistory();
  let turn = 0;

  const renderSome = () => {
    const batch = 10;
    const stop = Math.min(turn + batch, hist.length);

    const savedVars = State.active.variables;
    const savedTemp = Object.entries(State.temporary);
    try {
      for (; turn < stop; turn++) {
        const moment = hist[turn];

        if (turn !== 0) {
          $("<hr class=text-sep>").appendTo(outer);
        }

        const next = {};
        if (turn + 1 < hist.length) {
          next.title = hist[turn + 1].title;
          const V = hist[turn + 1].variables;
          if (V.g_mtaCodeTurn === turn + 2) {
            next.code = V.g_mtaCode;
          }
        }
        const div = tranRenderInternal(moment.title, moment.variables, turn, next);

        if (setup.playtest) {
          $("<div class=tran-title>")
            .text(moment.title)
            .prependTo(div);
        }

        $(outer).append(div);
      }
    } finally {
      State.active.variables = savedVars;
      State.clearTemporary();
      for (const [k, v] of savedTemp) {
        State.temporary[k] = v;
      }
    }
  };

  const renderLoop = () => {
    renderSome();
    if (turn < hist.length) {
      setTimeout(renderLoop);
    } else {
      renderDone();
    }
  };

  const renderDone = () => {
    const words = MT.countWords($(outer).text());
    const passages = hist.length;
    const minutes = Math.round(words / 250);
    let stats = `${passages} passages, ${words} words, ~${minutes} minutes`;
    $("#tran-stats").text(`(${stats})`);
  }
  
  renderLoop();
}

/**
 * <<tran-cut link>>
 * <<tran-cut text link>>
 * 
 * Emit link. In the transcript, if the player followed this link,
 * elide everything after this link in the passage.
 */
Macro.add("tran-cut", {
  handler: function() {
    const frag = document.createDocumentFragment();
    if (this.args.length === 1) {
      $(frag).wiki(this.args.raw);
    } else {
      $(frag).wiki(`<<link ${this.args.raw}>><</link>>`);
    }
    $(frag).find("a").addClass("tran-cut");
    $(this.output).append(frag);
  }
});

/**
 * <<tran-cut-span>>
 *   text
 * <</tran-cut-span>>
 * 
 * Emit text. In the transcript, if the player follows a link within
 * the text, elide everything after this block.
 */
Macro.add("tran-cut-span", {
  tags: [],
  handler: function() {
    const span = $("<span class=tran-cut-span>");
    span.wiki(this.payload[0].contents);
    $(this.output).append(span);
  }
});

<</script>>
