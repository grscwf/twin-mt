:: g0init Transcript [inclusion] {"position":"250,725","size":"100,100"}
<<append head>><style>

#tran-outer a {
  color: #aac;
  cursor: text;
}
#tran-outer ul.actions a {
  color: #669;
}
#tran-outer#tran-outer a.tran-next {
  color: #6ef;
}

#tran-outer ul.actions li::before {
  filter: saturate(0);
}

#tran-outer hr {
  border-color: #333;
}

#tran-outer .random-walk-chosen {
  outline: none;
}

.tran-entry {
  position: relative;
}

.tran-title {
  background-color: #111;
  border: 1px solid #333;
  border-radius: 4px;
  color: #666;
  font-size: 10px;
  padding: 0 4px;
  position: absolute;
  right: 0;
  top: -26px;
}

</style><</append>>

<<script>>

function cleanHtml(jq, nextTitle, nextCode) {
  jq.removeClass("passage-in");
  jq.find(".random-walk-chosen").removeClass("random-walk-chosen");
  jq.find(".fade-in-hidden").removeClass("fade-in-hidden");
  jq.find(".fade-in-absorb").removeClass("fade-in-absorb");
  jq.find(".tame-hide").removeClass("tame-hide");
  jq.find(".tran-remove").remove();
  jq.find("[data-name=silently]").remove();
  jq.find(".patience-debug").remove();
  jq.find(".ro-debug").remove();
  jq.find(".debug").replaceWith(function() { return $(this).contents(); });

  // highlight the link followed.
  if (nextTitle != null) {
    let link = jq.find(`a[data-passage="${nextTitle}"]`);
    if (link.length > 1 && nextCode != null) {
      link = link.filter(`[data-mta-code="${nextCode}"]`);
    }
    link.addClass("tran-next");
  }

  // remove trailing space and Continue/Return links
  const shouldRemove = el => {
    if (el.nodeName === "BR") return true;
    if (el.nodeName === "#text" && el.nodeValue.trim() === "") return true;
    if (el.nodeName === "A") {
      if (/^(Continue|Return)$/.test(el.textContent)) return true;
    }
    return false;
  };
  const el = jq[0];
  while (el.lastChild != null && shouldRemove(el.lastChild)) {
    el.lastChild.remove();
  }
}

MT.tranRender = output => {
  const outer = $("<div id=tran-outer>").appendTo(output);

  const hist = MT.getHistory();
  let turn = 0;

  const renderSome = () => {
    const batch = 10;
    const stop = Math.min(turn + batch, hist.length);

    const savedVars = State.active.variables;
    const savedTemp = Object.entries(State.temporary);
    try {
      for (; turn < stop; turn++) {
        const moment = hist[turn];

        $("<hr class=text-sep>").appendTo(outer);


        let nextTitle = null;
        let nextCode = null;
        if (turn + 1 < hist.length) {
          nextTitle = hist[turn + 1].title;
          const V = hist[turn + 1].variables;
          if (V.g_mtaCodeTurn === turn + 1) {
            nextCode = V.g_mtaCode;
          }
        }

        const text = Story.get(moment.title).text;
        State.active.variables = clone(moment.variables);
        State.clearTemporary();

        let div = $("<div class=tran-entry>");

        if (setup.tester) {
          $("<div class=tran-title>").text(moment.title)
            .appendTo(div);
        }

        MT.suppressErrors(() => {
          div.wiki(text);
        });
        // clone to remove event handlers
        div = div.clone();

        cleanHtml(div, nextTitle, nextCode);
        $(outer).append(div);
      }
    } finally {
      State.active.variables = savedVars;
      State.clearTemporary();
      for (const [k, v] of savedTemp) {
        State.temporary[k] = v;
      }
    }
  };

  const renderLoop = () => {
    renderSome();
    if (turn < hist.length) {
      setTimeout(renderLoop);
    } else {
      const words = MT.countWords($(outer).text());
      const passages = hist.length;
    }
  };
  
  renderLoop();
}

Macro.add("tran-skip", {
  tags: [],
  handler: function() {
    const outer = $("<span class=tran-remove>").appendTo(this.output);
    outer.wiki(this.payload[0].text);
  }
});

<</script>>
