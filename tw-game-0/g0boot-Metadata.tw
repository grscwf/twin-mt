:: g0boot Metadata [inclusion] {"position":"235,425","size":"100,100"}
<<script>>
/* `_m` is a JS global that's a proxy for State.metadata. Details below. */

/** metavar is not added to saved games. */
const NOT_SAVED = 0;

/** metavar is added to saved games. */
const SAVED = 1;

/** metavar is not added to saved games, and not erased on reset.  */
const EXCLUDED = 3;

/** all metavars should be declared here. */
const allMetavars = {
  // Drekkar endings
  dxEnthrallment: SAVED,
  dxEnthrallmentLion: SAVED,
  dxExtractionGentle: SAVED,
  dxExtractionForceful: SAVED,
  dxInterrogationFreeze: SAVED,
  dxInterrogationMild: SAVED,
  dxInterrogationRough: SAVED,
  dxInterrogationShock: SAVED,
  dxIvexEnthrallment: SAVED,
  dxIvexExtraction: SAVED,
  dxIvexPunishment: SAVED,

  // Game persistent state
  gmPassedContentWarning: NOT_SAVED,
  gmTitleSeen: NOT_SAVED,
  gmVisited: NOT_SAVED,

  // Keywords unlocked
  kwAntiMagic: SAVED,
  kwDream: SAVED,
  kwEndgame: SAVED,
  kwGravity: SAVED,
  kwItch: SAVED,
  kwIvex: SAVED,
  kwKelvin: SAVED,
  kwKopic: SAVED,
  kwMcBasics: SAVED,
  kwMcInhibition: SAVED,
  kwMcRepression: SAVED,
  kwMcSubstitution: SAVED,
  kwMica: SAVED,
  kwNackle: SAVED,
  kwOil: SAVED,
  kwPearson: SAVED,
  kwPevhin: SAVED,
  kwPyron: SAVED,
  kwSprite: SAVED,
  kwTigerKeratin: SAVED,
  kwTigerMyth: SAVED,
  kwYounger: SAVED,

  // Nero persistent state
  neIvexRememberedEndgame: NOT_SAVED,
  nePlayerLeftStudy: NOT_SAVED,
  nePlayerLeftStudyWithMirror: NOT_SAVED,
  nePlayerReadGlitch: NOT_SAVED,

  // Notes do not get added to saved games, and do not get erased
  notes: EXCLUDED,

  // Nero endings unlocked
  nxBroken: SAVED,
  nxCagedHarsh: SAVED,
  nxCagedMild: SAVED,
  nxTamedHarsh: SAVED,
  nxTamedMild: SAVED,
};

/**
 * `_m` is a JS global that's a proxy for State.metadata.
 * 
 * The proxy is also installed as the SugarCube temp var `_m`,
 * so that the expression `_m.var` can be used anywhere.
 * 
 * Note, get is somewhat expensive, since it always reads and
 * deserializes from localStorage. Bulk read operations should maybe
 * filter State.metadata.entries() instead.
 */
window._m = new Proxy({}, {
  deleteProperty(target, prop) {
    if (typeof prop === "symbol") {
      return Reflect.deleteProperty(target, prop);
    }
    checkIsKnown(prop, "delete");
    State.metadata.delete(prop);
    return true;
  },
  get(target, prop, receiver) {
    if (typeof prop === "symbol") {
      return Reflect.get(target, prop, receiver);
    }
    checkIsKnown(prop, "get");
    return State.metadata.get(prop);
  },
  // TODO: implement getOwnPropertyDescriptor and ownKeys to allow enumeration
  set(target, prop, value, receiver) {
    if (typeof prop === "symbol") {
      return Reflect.set(target, prop, value, receiver);
    }
    checkIsKnown(prop, "set");
    if (value == null || value === false) {
      State.metadata.delete(prop);
    } else {
      State.metadata.set(prop, value);
    }
    return value;
  },
});

function checkIsKnown(name, verb) {
  if (typeof name === "symbol") return;
  if (name in allMetavars) return;
  throw new Error(`${verb} of nonexistent metavar _m.${name}`);
}

/** Returns an object-map of all current metadata entries. */
MT.metaRecord = () => {
  const entries = State.metadata.entries() || [];
  const record = Object.fromEntries(entries);
  return record;
};

/** Erases all metadata, except EXCLUDED metavars */
MT.metaClear = () => {
  const entries = State.metadata.entries();
  const preserve = [];
  for (const [key, value] of entries) {
    if (allMetavars[key] === EXCLUDED) {
      preserve.push([key, value]);
    }
  }
  State.metadata.clear();
  for (const [key, value] of preserve) {
    State.metadata.set(key, value);
  }
};

function metaLoad(save) {
  if (!save.metadata) return;
  const current = MT.metaRecord();
  for (const [key, value] of Object.entries(save.metadata)) {
    if (value && allMetavars[key] === SAVED && !current[key]) {
      _m[key] = value;
      // XXX announce the unlock
    }
  }
}

function metaSave(save) {
  save.metadata ||= {};
  const entries = State.metadata.entries();
  for (const [key, value] of entries) {
    if (allMetavars[key] === SAVED) {
      save.metadata[key] = value;
    }
  }
}

function metaInit() {
  $(document).on(":passageinit", () => {
    State.temporary.m = _m;
  });
  Save.onLoad.add(metaLoad);
  Save.onSave.add(metaSave);
}

/**
 * <<meta-ending [good|bad] varname text>>
 * Announce an ending. If it's locked, unlock it, and announce the unlocking.
 */
Macro.add("meta-ending", {
  handler: function() {
    const [type, vname, text] = this.args;
    if (!_m[vname]) {
      $(this.output).append(
        `<meta-text>${text} is now unlocked in the Archive.</meta-text>`);
      _m[vname] = true;
    } else {
      $(this.output).append(
        `<meta-ending-${type}>${text}</meta-ending-${type}>`);
    }
  }
});

metaInit();

<</script>>
