:: g0boot Metadata [inclusion] {"position":"235,425","size":"100,100"}
<<script>>

/**
 * State.metadata vars that do not get added to saved games.
 */
const unsavedVars = new Set([
  // Game persistent state
  "gmPassedContentWarning",
  "gmTitleSeen",

  // Nero persistent state
  "neIvexRememberedEndgame",
  "nePlayerLeftStudy",
  "nePlayerLeftStudyWithMirror",
  "nePlayerReadGlitch",

]);

/**
 * State.metadata vars that are saved and loaded from saved games.
 */
const savedVars = new Set([
  // Drekkar endings
  "dxEnthrallment",
  "dxEnthrallmentLion",
  "dxExtractionGentle",
  "dxExtractionForceful",
  "dxInterrogationFreeze",
  "dxInterrogationMild",
  "dxInterrogationRough",
  "dxInterrogationShock",
  "dxIvexEnthrallment",
  "dxIvexExtraction",
  "dxIvexPunishment",

  // Keywords unlocked
  "kwAntiMagic",
  "kwDream",
  "kwEndgame",
  "kwGravity",
  "kwItch",
  "kwIvex",
  "kwKelvin",
  "kwKopic",
  "kwMcFundamental",
  "kwMcInhibition",
  "kwMcRepression",
  "kwMcSubstitution",
  "kwMica",
  "kwNackle",
  "kwOil",
  "kwPearson",
  "kwPevhin",
  "kwPyron",
  "kwSprite",
  "kwTigerKeratin",
  "kwTigerMyth",
  "kwYounger",

  // Nero endings unlocked
  "nxBroken",
  "nxCagedHarsh",
  "nxCagedMild",
  "nxTamedHarsh",
  "nxTamedMild",
]);

/**
 * `_m` is a JS global that's a proxy for State.metadata.
 * 
 * The proxy is also installed as the SugarCube temp var `_m`,
 * so that the expression `_m.var` can be used anywhere.
 * 
 * Note, get is somewhat expensive, since it always reads and
 * deserializes from localStorage. Bulk read operations should maybe
 * filter State.metadata.entries() instead.
 */
window._m = new Proxy({}, {
  deleteProperty(target, prop) {
    if (typeof prop === "symbol") {
      return Reflect.deleteProperty(target, prop);
    }
    checkIsKnown(prop, "delete");
    State.metadata.delete(prop);
  },
  get(target, prop, receiver) {
    if (typeof prop === "symbol") {
      return Reflect.get(target, prop, receiver);
    }
    checkIsKnown(prop, "get");
    return State.metadata.get(prop);
  },
  // TODO: implement getOwnPropertyDescriptor and ownKeys to allow enumeration
  set(target, prop, value, receiver) {
    if (typeof prop === "symbol") {
      return Reflect.set(target, prop, value, receiver);
    }
    checkIsKnown(prop, "set");
    if (value == null || value === false) {
      State.metadata.delete(prop);
    } else {
      State.metadata.set(prop, value);
    }
    return value;
  },
});

function checkIsKnown(name, verb) {
  if (typeof name === "symbol") return;
  if (unsavedVars.has(name)) return;
  if (savedVars.has(name)) return;
  throw new Error(`${verb} of nonexistent meta var _m.${name}`);
}

MT.metaClear = () => {
  // Preserve notes
  const notes = State.metadata.get("notes");
  State.metadata.clear();
  State.metadata.set("notes", notes);
};

function metaLoad(save) {
  if (!save.metadata) return;
  for (const [key, value] of Object.entries(save.metadata)) {
    if (!savedVars.has(key)) continue;
    if (!value) continue;
    if (!_m[key]) {
      _m[key] = value;
      // XXX announce the unlock
    }
  }
}

function metaSave(save) {
  save.metadata ||= {};
  const entries = State.metadata.entries();
  for (const [key, value] of entries) {
    if (savedVars.has(key)) {
      save.metadata[key] = value;
    }
  }
}

function metaInit() {
  $(document).on(":passageinit", () => {
    State.temporary.m = _m;
  });
  Save.onLoad.add(metaLoad);
  Save.onSave.add(metaSave);
}

metaInit();

<</script>>
