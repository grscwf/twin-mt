:: g0boot Metadata [inclusion] {"position":"235,425","size":"100,100"}
<<script>>
/*----------------
 * This module handles game metadata, including saving and loading
 * the metadata in saved games.
 */

/** Record of metadata key -> save type. */
const knownKeys = {};

const UNSAVED = 0;
const SAVED = 1;
const PRESERVED = 2;

/** If `key` is not known, reports a warning and returns true. */
function warnUnknownKey(key) {
  if (!(key in knownKeys)) {
    MT.diag(`Warning: unknown metadata key ${key}`);
    return true;
  }
  return false;
}

/** If `key` is already known, reports a warning and returns true. */
function warnKnownKey(key) {
  if (key in knownKeys) {
    MT.diag(`Warning: metadata key ${key} already exists.`);
    return true;
  }
  return false;
}

/**
 * Defines `key` to be unsaved metadata, which means:
 * - it persists across game resets.
 * - it doesn't get stored in saved games.
 * - it gets deleted in a metadata reset.
 * 
*/
MT.mdDefUnsaved = (key) => {
  if (warnKnownKey(key)) return;
  knownKeys[key] = UNSAVED;
};

/**
 * Defines `key` to be saved metadata, which means;
 * - it persists across game resets.
 * - it gets stored in saved games.
 * - loading a saved game will set (but not overwrite) its value.
 * - it gets deleted in a metadata reset.
 */
MT.mdDefSaved = (key) => {
  if (warnKnownKey(key)) return;
  knownKeys[key] = SAVED;
};

/**
 * Defines `key` to be preserved metadata, which means:
 * - it persists across game resets.
 * - it doesn't get stored in saved games.
 * - it doesn't get deleted in a metadata reset.
 */
MT.mdDefPreserved = (key) => {
  if (warnKnownKey(key)) return;
  knownKeys[key] = PRESERVED;
};

/**
 * Returns the value of metadata `key`.
 * 
 * Note, each call will always decompress and deserialize
 * all metadata from localStorage, so it's somewhat expensive.
 * Use `MT.mdRecord` if you want to read more than a few values at a time.
 */
MT.mdGet = (key) => {
  warnUnknownKey(key);
  return State.metadata.get(key);
};

/**
 * Sets metadata `key` to `value`. Any false-y value will delete the key.
 * 
 * Note, each call will always decompress and deserialize
 * all metadata from localStorage, then reserialize and recompress
 * back to localStorage. So this is very expensive, and SugarCube
 * doesn't give us a way to batch multiple set operations
 * (other than bypassing SugarCube and doing it ourselves.)
 */
MT.mdSet = (key, value) => {
  warnUnknownKey(key);
  if (value) {
    State.metadata.set(key, value);
  } else {
    State.metadata.delete(key);
  }
};

/** Returns an array of all [key, value] metadata entries. */
MT.mdEntries = () => {
  return State.metadata.entries() || [];
};

/** Returns a record (object-map) of all metadata keys and values. */
MT.mdRecord = () => {
  return Object.fromEntries(MT.mdEntries());
};

/** Deletes all metadata, except for PRESERVED keys and unknown keys. */
MT.mdReset = () => {
  const preserve = [];
  const entries = State.metadata.entries() || [];
  for (const [key, value] of entries) {
    warnUnknownKey(key);
    if (knownKeys[key] === PRESERVE) {
      preserve.push([key, value]);
    }
  }
  State.metadata.clear();
  for (const [key, value] of preserve) {
    State.metadata.set(key, value);
  }
};

/*----------------
 * Saving and loading metadata.
 */

function mdLoad(save) {
  if (!save.metadata) return;
  const current = MT.mdRecord();
  for (const [key, value] of Object.entries(save.metadata)) {
    if (value && knownKeys[key] === SAVED && !current[key]) {
      State.metadata.set(key, value);
      // XXX announce the unlock
    }
  }
}

function mdSave(save) {
  save.metadata ||= {};
  const entries = State.metadata.entries() || [];
  for (const [key, value] of entries) {
    if (knownKeys[key] === SAVED) {
      save.metadata[key] = value;
    }
  }
}

function mdInit() {
  Save.onLoad.add(mdLoad);
  Save.onSave.add(mdSave);
}

mdInit();

<</script>>
