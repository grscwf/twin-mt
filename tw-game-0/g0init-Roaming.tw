:: g0init Roaming [inclusion] {"position":"700,850","size":"100,100"}
<<append head>><style>
  #random-walk {
    top: max(5rem, 50vh - 5rem);
    display: flex;
    flex-direction: column;
    font-size: 18px;
    gap: 20px;
    position: fixed;
    right: 4px;
    z-index: 20;
  }

  #random-walk a {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 4px;
    color: #000;
    cursor: pointer;
    opacity: 0.1;
    padding: 2px 4px;
    text-align: center;
    user-select: none;
  }

  #random-walk a:hover {
    background-color: #333;
    border-color: #eee;
    color: #eee;
    opacity: 1;
  }

  .random-walk-chosen {
    outline: 1px solid #9cc;
  }

  #rw-roam.rw-roaming {
    background-color: #161;
    color: #7f7;
    opacity: 1;
  }
  #rw-roam.rw-roaming:hover {
    background-color: #191;
    color: #111;
  }
</style><</append>>

<<script>>

const milestones = new Set([
  "n1p Barbs Fast 1",
  "n1p Barbs Slow 1",
  "n1p Barbs Slow 2a1",
  "n1p Barbs Slow 2n1",
  "n1p Barbs Slow 2s1",
  "n1p Barbs Skip",
  "n1s Cast Alone 1",
  "n1s Cast Endgame 1",
  "n1s Cast Horny 1",
  "n1s Cast Itch 2",
  "n1s Cast Sight 1",
  "n1s Cast Sight Horny",
  "n1s Cast Younger 1",
  "n1s Guess Password",
  "n1s Impatient",
  "n1s Say Device",
  "n1s Say Lance",
  "n1s Say Password",
  "n1s Tap 1",
  "n1s Zero Bound",
]);

const visited = new Set();
let lastPick = {};

let ignoreFuture = false;

MT.roaming = false;

MT.forgetWalkHistory = () => {
  visited.clear();
  lastPick = {};
};

/** Random walk */
function initRandomWalk() {
  if (!setup.tester) return;

  const idOf = el => {
    const title = $(el).attr("data-passage");
    const mtaCode = $(el).attr("data-mta-code");
    return `${title}/${mtaCode}`;
  };

  function updateLabel() {
    const el = $("#rw-forw");
    if (State.length === State.size || ignoreFuture) {
      el.text("rand");
    } else {
      el.text("forw");
    }
  }

  const goRandom = () => {
    const V = State.variables;

    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      ignoreFuture = false;
      chosen.click();
      return true;
    }
    chosen.removeClass("random-walk-chosen");

    const here = State.passage;
    const all = $("#passages a[data-passage]");
    if (all.length === 0) return false;

    let avail = all;

    // bias toward climbing the ladder of magic.
    let important = "[data-mta-code*='//prefer']";
    switch (V.n_magicPhase) {
      case MP_beforeCast:
        important += ", [data-passage*=Cast]:not([data-passage*=Itch])";
        break;
      case MP_triedMagic:
        if (!V.n_mageSight) {
          important += ", [data-passage*=Sight]";
        } else {
          important += ", [data-passage*=Mirror], [data-passage*=Tap]";
        }
        break;
      case MP_wantDevice:
        important += ", [data-passage*=Say]";
        break;
      case MP_wantName:
        important += ", [data-passage*=Say], [data-passage*=Ask]";
        important += ", [data-passage*=Bottle]";
        break;
      case MP_wantTouch:
        important += ", [data-passage*=Ask], [data-passage*=Penguin]";
        break;
      case MP_wantPass:
        important += ", [data-passage*=Password], [data-passage*=Ask]";
        break;
    }
    const prefer = all.filter(important);
    if (prefer.length && Math.random() < .7) {
      const names = prefer.map((i, el) => $(el).attr("data-passage"));
      console.log(`prefer [${[...names].join(",")}]`);
      avail = prefer;
    } else {
      avail = avail.filter((i, el) => !visited.has(idOf(el)));
    }
    let pick = null;
    while (pick == null) {
      if (avail.length === 0) {
        all.each((i, el) => visited.delete(idOf(el)));
        avail = all;
        if (avail.length > 1) {
          // avoid picking the link we just picked
          avail = avail.filter((i, el) => idOf(el) !== lastPick[here]);
          if (avail.length === 0) avail = all;
        }
      }

      // Should not use State.random()
      const i = Math.floor(avail.length * Math.random());
      pick = avail[i];
      const code = $(pick).attr("data-mta-code");
      const avoid = code != null && code.includes("//avoid");
      if (avoid && Math.random() < .9) {
        const title = $(pick).attr("data-passage");
        console.log(`avoiding ${title}`);
        pick = null;
        avail.splice(i, 1);
      }
    }
    $(pick).addClass("random-walk-chosen");
    pick.scrollIntoView(false);
    lastPick[here] = idOf(pick);
    visited.add(lastPick[here]);
    return true;
  };

  const goBack = () => {
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length > 0) {
      ignoreFuture = true;
      chosen.removeClass("random-walk-chosen");
      updateLabel();
    } else {
      ignoreFuture = false;
      Engine.backward();
    }
  };

  const goForward = () => {
    if (State.length === State.size || ignoreFuture) {
      goRandom();
      return;
    }
    ignoreFuture = false;

    const next = State.history[State.length].title;
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      if (chosen.attr("data-passage") === next) {
        Engine.forward();
      } else {
        goRandom();
      }
      return;
    }
    chosen.removeClass("random-walk-chosen");
    const links = $("#passages a[data-passage]")
      .filter((i, el) => $(el).attr("data-passage") === next);
    if (links.length === 1) {
      links.addClass("random-walk-chosen");
      links[0].scrollIntoView(false);
    } else {
      Engine.forward();
    }
  };

  let roamForce = false;
  let roamLoop = 0;
  let roamLooping = false;
  let roamMoved = false;
  let roamPath = null;
  let roamDoneFn = null;

  const roamDelay = 50;
  const maxLoop = 5;

  const roamToggle = () => {
    if (MT.roaming) {
      roamStop();
    } else {
      roamStart();
    }
  };

  const roamStart = MT.roamStart = (path, doneFn, force) => {
    $("#rw-roam").addClass("rw-roaming");
    MT.roaming = true;
    roamForce = force;
    roamMoved = false;
    roamPath = path;
    roamDoneFn = doneFn;
    setTimeout(roamNext, roamDelay);
  };

  const roamStop = () => {
    MT.roaming = false;
    roamPath = null;
    roamDoneFn = null;
    $("#rw-roam").removeClass("rw-roaming");
  };

  const roamNext = () => {
    const here = State.passage;

    if (!MT.roaming) return roamStop();
    if (roamMoved && here === Config.passages.start) return roamStop();

    let hasProblem = false;
    hasProblem = hasProblem || MT.hasFails;
    hasProblem = hasProblem || MT.hasWarnings;
    hasProblem = hasProblem || $(".error-view").length !== 0;

    let hasTodo = /\bX[X]X\b|\bTO[D]O\b/.test($(".passage").text());

    const isDraft = MT.isDraft(here);
    const stop = tags().includes("roam-stop");

    if (roamMoved) {
      if (hasProblem) {
        console.log('stopping on problem');
        return roamStop();
      }
      if (!roamForce && (hasTodo || isDraft)) {
        console.log('stopping on to-do');
        return roamStop();
      }
      if (stop) {
        const steps = MT.log.length;
        const V = State.variables;
        console.log(`stop after ${steps} steps at ${here}`);
        const mp = MT.enumSymbol('MagicPhase', V.n_magicPhase);
        const mpr = MT.enumSymbol('MagicPhase', V.n_magicPhaseReached);
        console.log(`- magicPhase ${mp}, ${mpr}`);
        if (roamLoop <= 0) {
          if (roamLooping) {
            roamLooping = false;
            console.log("stop at max loops");
          }
          return roamStop();
        }
      }
    }

    if (!roamMoved) {
      if (hasTodo || isDraft) {
        roamForce = true;
      }
      if (stop) {
        roamLoop = maxLoop;
        roamLooping = true;
      }
    }

    if (stop) {
      roamLoop--;
      if (roamLoop <= 0) {
        roamLooping = false;
        console.log("stop at max loops");
        return roamStop();
      }
      MT.forgetWalkHistory();
      Engine.play("g1a Bound");
      roamForce = false;
      const neroStart = [
        { t: "g1a Choose Character" },
        { t: "n1a Nero Start" },
      ];
      MT.roamStart(neroStart, () => {
        MT.roamStart();
      });
      return;
    }

    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      roamMoved = true;
      chosen[0].click();
      setTimeout(roamNext, roamDelay);
      return;
    }

    if (roamLoop && roamPath != null && roamPath.length === 0) {
      roamPath = null;
    }

    if (roamPath != null) {
      while (roamPath.length && roamPath[0].t == null) {
        roamPath.shift();
      }
      if (roamPath.length === 0) {
        const steps = MT.log.length;
        console.log(`path end after ${steps} steps at ${here}`);
        if (roamDoneFn != null) setTimeout(roamDoneFn);
        roamStop();
        return;
      }
      const next = roamPath[0];
      const links = $("#story a[data-passage]");
      const isStep = (el, step) => {
        const title = el.getAttribute("data-passage");
        const code = el.getAttribute("data-mta-code") || null;
        return title === step.t &&
          (code == null || step.code == null || code === step.code);
      };
      for (const link of links) {
        if (isStep(link, next)) {
          roamPath.shift();
          $(link).addClass("random-walk-chosen");
          setTimeout(roamNext, 100);
          return;
        }
      }

      let msg = `Broken path: ${JSON.stringify(next)}`;
      MT.warn(msg);
      return roamStop();
    }

    if (milestones.has(here)) {
      console.log(`milestone ${here}`);
    }

    if (goRandom()) {
      setTimeout(roamNext, roamDelay);
      return;
    }
    
    roamStop();
  };

  $(() => {
    $("#random-walk").remove();
    const outer = $("<div>")
      .attr("id", "random-walk")
      .appendTo("#story");
    $("<a>")
      .attr("title", "<ctrl-comma> backward")
      .text("back")
      .click(goBack)
      .appendTo(outer);
    if (setup.debug) {
      $("<a id=rw-roam>")
        .attr("title", "<ctrl-backslash> roam")
        .toggleClass("rw-roaming", MT.roaming)
        .text("roam")
        .click(roamToggle)
        .appendTo(outer);
    }
    $("<a id=rw-forw>")
      .attr("title", "<ctrl-period> forward or random")
      .text("forw")
      .click(goForward)
      .appendTo(outer);
    updateLabel();
  });

  // ctrl-comma doesn't generate keypress events
  $(document).on("keydown", ev => {
    if (!ev.ctrlKey) return;
    const focus = document.activeElement;
    const tag = focus != null ? focus.tagName : "";
    if (/^(textarea|input|select)$/i.test(tag)) return;
    if (ev.key === ",") return goBack();
    if (ev.key === ".") return goForward();
    if (ev.key === "/") return roamToggle();
  });

  $(document).on("click", ev => {
    if (!MT.roaming && ev.target && ev.target.tagName !== "A") {
      const chosen = $("#passages .random-walk-chosen");
      if (chosen.length) {
        chosen.removeClass("random-walk-chosen");
        ignoreFuture = true;
        updateLabel();
      }
    }
  });

  $(document).on(":passagestart", () => {
    updateLabel();
  });
}

initRandomWalk();
<</script>>
