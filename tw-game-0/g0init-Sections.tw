:: g0init Sections [inclusion] {"position":"100,1000","size":"100,100"}
<<script>>

// Passages are grouped into sections by a prefix code in their title.
// - Prefix should start with a lowercase letter, followed by a number,
//   followed by more lowercase numbers.
// - Prefix should be separated from the rest of the passage title with
//   a space or `-`.
// - Use prefixes that are not words used elsewhere. This makes it easy to
//   search for all occurrences of a passage title.

/** Passages that don't have a section code prefix */
const specialTitles = new Set([
  // Twee special passages
  "Story JavaScript",
  "Story Stylesheet",
  
  // Twine special passages
  "StoryAuthor",
  "StoryBanner",
  "StoryData",
  "StoryDisplayTitle",
  "StoryInit",
  "StoryMenu",
  "StoryTitle",
]);

// For each section:
// - `expect` is state vars that are expected to be specific values.
//   - The value `false` means it can be `false`, `undefined`, or `null`.
//   - Any other value must match exactly.
//   - There usually doesn't need to be a declaration for false in
//     sections before a state var is ever set.
//   - There probably should be a declaration for false if a state var
//     can become false, to verify all paths do set it to false.
// - `notable` is state vars that should affect the passage text.
//   - The value can be `true` or a regex.
//   - A regex means, passage should use the state var only if its text
//     matches that regex.

const sectionDefs = {

  // Passages loaded early during StoryInit
  g0boot: {},

  // Passages loaded after g0boot, during StoryInit
  g0init: {},

  // Story opening passages
  g1a: {},

  // Story meta passages
  g1m: {},

  // Drekkar meta passages
  d0a: {},

  // Drekkar 1F until Ivex leaves
  d1a: {},

  // Drekkar 1F after Ivex leaves
  d2a: {},

  // Drekkar 2F
  d3a: {},

  // Drekkar outside
  d4a: {},

  // Drekkar bad endings
  d9a: {},

  // Drekkar good endings
  d9x: {},

  // Nero meta passages
  n0a: {},

  // Nero 1F intro
  n1a: {
    notable: {
      n1_mageSight: true,
    }
  },

  // Nero convo, neutral mood
  n1cn: {
    notable: {
      n1_abused: true,
      n1_mageSight: true,
      n1_naked: true,
    }
  },

  // Nero convo, Ivex receptive
  n1cr: {
    expect: {
      t_ivexReceptive: true,
    },
    notable: {
      n1_abused: true,
      n1_mageSight: true,
      n1_naked: true,
    }
  },

  // Nero convo, subby mood
  n1cs: {
    expect: {
      n1_naked: true,
      n1_subby: true,
      t_ivexReceptive: true,
    },
    notable: {
      // n1_abused: subby usually dominates
      n1_mageSight: true,
    }
  },

  // Nero convo, transition to candle
  n1cx: {
    expect: {
      t_ivexReceptive: false,
    },
    notable: {
      n1_abused: true,
      n1_mageSight: true,
      n1_naked: true,
      n1_subby: true,
      n1_tough: true,
    }
  },

  // Nero candle lit
  n1d: {
    expect: {
      n1_candleLit: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_abused: true,
      n1_mageSight: true,
      n1_naked: true,
      n1_subby: true,
      n1_tough: true,
    }
  },
  
  // Nero candle horny
  n1e: {
    expect: {
      n1_candleHorny: true,
      n1_candleLit: true,
      n1_naked: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_abused: true,
      n1_mageSight: true,
      n1_subby: true,
      n1_tough: true,
    }
  },

  // Nero being clever
  n1f: {
    expect: {
      n1_naked: true,
    }
  },

  // Nero barbs choice
  n1p: {
    expect: {
      n1_candleHorny: false,
      n1_mageSight: false,
    }
  },

  // Nero magic/sprite
  n1s: {
    expect: {
      n2_free: false,
    },
    notable: {
      // make sure Ivex is wearing mask when candle lit
      n1_candleLit: /ivex/im,
      n2_ivexGone: true,
    }
  },

  // Nero looking
  n1x: {
    expect: {
      n1_candleHorny: false,
    },
    notable: {
      // make sure Ivex is wearing mask when candle lit
      n1_candleLit: /ivex/im,
      n1_mageSight: true,
      n2_free: true,
      n2_ivexGone: true,
    }
  },

  // Nero horny looking
  n1y: {
    expect: {
      n1_candleHorny: true,
      n1_candleLit: true,
      n1_naked: true,
    },
    notable: {
      n1_mageSight: true,
      n2_ivexGone: true,
    }
  },

  // Nero 1F alone intro
  n2a: {
    expect: {
      n1_candleHorny: false,
      n1_candleLit: false,
      n1_naked: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_mageSight: true,
    }
  },

  // Nero alone with candle
  n2b: {
    expect: {
      n1_candleLit: true,
      n1_naked: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_mageSight: true,
    }
  },

  // Nero escaping cross
  n2c: {
    expect: {
      n1_naked: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_mageSight: true,
    }
  },

  // Nero free on 1F
  n2f: {
    expect: {
      n1_naked: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_mageSight: true,
      n2_extraHorny: true,
      n2_tooClever: true,
    }
  },

  // Nero looking while free
  n2x: {
    expect: {
      n1_naked: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_mageSight: true,
      n2_extraHorny: true,
      n2_tooClever: true,
    }
  },

  // Nero 2F sketch
  n3a: {
    expect: {
      n1_naked: true,
      n2_ivexGone: true,
      t_ivexReceptive: false,
    },
    notable: {
      n1_mageSight: true,
      n2_extraHorny: true,
    }
  },

  // Nero 1F endings
  n9a: {
    expect: {
      n1_naked: true,
    },
  },

  // Nero 2F endings
  n9e: {},

  // Nero escaped endings
  n9x: {},

  // Passages without a section tag
  other: {},
};

/** Returns section name of passageTitle. */
const sectOf = (passageTitle) => {
  const re = /^([a-z][a-z0-9]+)[- ]/;
  const m = re.exec(passageTitle);
  return m ? m[1] : "other";
};

/** Returns section name of current passage. */
MT.sectHere = () => sectOf(State.passage);

/** Returns expected state in sect. */
MT.sectExpect = (sect) => sectionDefs[sect].expect;

MT.varExpect = (vname) => {
  const sect = MT.sectHere();
  if (!sectionDefs[sect]) return null;
  const expect = sectionDefs[sect].expect || {};
  return expect[vname];
};

MT.isNotable = (sect, vname) => {
  if (!sectionDefs[sect]) return null;
  const notable = sectionDefs[sect].notable;
  if (!notable) return false;
  const exp = notable[vname];
  if (exp instanceof RegExp) {
    const text = Story.get(State.passage);
    return notable[vname].test(text);
  }
  return exp;
};

MT.allNotable = () => {
  const sect = MT.sectHere();
  if (!sectionDefs[sect]) return [];
  const notable = sectionDefs[sect].notable;
  if (!notable) return [];
  const result = [];
  let text = null;
  for (const [vn, exp] of Object.entries(notable)) {
    if (exp instanceof RegExp) {
      if (text == null) text = Story.get(State.passage);
      if (exp.test(text)) result.push(vn);
    } else if (exp) {
      result.push(vn);
    }
  }
  return result;
};

/** Validates sectionDefs and passage titles. */
function checkSections() {
  if (!setup.debug) return;

  // Verify every passage title has a valid section tag.
  const sectsUsed = new Set();
  for (const p of Story.lookup()) {
    const sect = sectOf(p.title);
    if (!sectionDefs[sect] && !sectsUsed.has(sect)) {
      console.error(`[\[${p.title}]] section ${sect} not defined`);
    }
    sectsUsed.add(sect);
  }

  // Verify all section tags are used.
  for (const sect of Object.keys(sectionDefs)) {
    if (!sectsUsed.has(sect)) {
      console.error(`section ${sect} is never used`);
    }
  }

  // Verify sectionDefs have a sensible structure
  const expectedKeys = ["expect", "notable"];
  for (const [sect, def] of Object.entries(sectionDefs)) {
    const typos = Object.keys(def).filter(k => expectedKeys.indexOf(k) < 0);
    if (typos.length) {
      console.error(`sectionDefs.${sect} has unknown keys [${typos}]`);
    }
  }
}

/** Verifies stateObj is correct for sectName. */
MT.checkSectionState = (stateObj, sectName, quietly, onlySet) => {
  if (!sectionDefs[sectName]) return;
  const expect = sectionDefs[sectName].expect;
  if (!expect) return true;
  let allOk = true;
  for (const [vn, val] of Object.entries(expect)) {
    if (onlySet && !onlySet.has(vn)) continue;
    const ok = stateObj[vn] === val || (val === false && stateObj[vn] == null);
    if (!ok) {
      if (quietly) return false;
      allOk = false;
      MT.fail(`${vn} should be ${val} in ${sectName}, not ${stateObj[vn]}`);
    }
  }
  return allOk;
}

/** Verifies current state is correct at current location. */
function checkSectionStateHere() {
  // Note, incoming state, not modified state.
  const s0 = State.current.variables;
  const sect = MT.sectHere();
  // TODO: remove this temp hack when restart is fixed
  if (s0.t_restarting) return;
  MT.checkSectionState(s0, sect, false);
}

checkSections();
$(document).on(":passageend", checkSectionStateHere);

<</script>>
