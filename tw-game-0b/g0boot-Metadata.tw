:: g0boot Metadata [inclusion] {"position":"500,275","size":"100,100"}
<<script>>
/*----------------
 * This module manages game metadata.
 * It's mostly a wrapper around SugarCube's metadata, with:
 * - "clear metadata" that preserves keys marked IGNORED.
 * - saving and loading keys marked SAVED to saved games.
 * - copying metadata to State.variables for easy access and debug tooling.
 *
 * Note, the values copied to State.variables are writable,
 * but writing them *does not* write to metadata.
 * Persisting a value needs to use `MT.mdSet`.
 */

// metadata types
const UNSAVED = 1;
const SAVED = 2;
const IGNORED = 3;

/** metadata key -> metadata type. */
const knownKeys = {};

/** If `key` is not known, reports a warning and returns true. */
function warnUnknownKey(key) {
  if (!(key in knownKeys)) {
    MT.diag(`Warning: unknown metadata key ${key}`);
    return true;
  }
  return false;
}

/** If `key` is already known, reports a warning and returns true. */
function warnKnownKey(key) {
  if (key in knownKeys) {
    MT.diag(`Warning: metadata key ${key} already exists.`);
    return true;
  }
  return false;
}

/**
 * Defines `key` to be UNSAVED metadata, which means:
 * - it ISN'T stored in saved games.
 * - it IS mirrored to State.variables.
 * - it IS deleted by "clear metadata".
*/
MT.mdDefUnsaved = (key) => {
  if (warnKnownKey(key)) return;
  knownKeys[key] = UNSAVED;
};

/**
 * Defines `key` to be SAVED metadata, which means;
 * - it IS stored in saved games.
 * - it IS mirrored to State.variables.
 * - it IS deleted by "clear metadata".
 * - loading a saved game will set its value from the saved game,
 *   but only if it isn't already set.
 */
MT.mdDefSaved = (key) => {
  if (warnKnownKey(key)) return;
  knownKeys[key] = SAVED;
};

/**
 * Defines `key` to be IGNORED metadata, which means:
 * - it ISN'T stored in saved games.
 * - it ISN'T mirrored to State.variables.
 * - it ISN'T deleted by "clear metadata".
 */
MT.mdDefIgnored = (key) => {
  if (warnKnownKey(key)) return;
  knownKeys[key] = IGNORED;
};

/** True if `key` is a known metadata key. */
MT.mdKnown = (key) => knownKeys[key] != null;

/**
 * Returns the value of metadata `key`.
 *
 * Note, each call will always decompress and deserialize
 * all metadata from localStorage, so this is somewhat expensive.
 *
 * If you don't need the authoritative value, you can read the
 * copy in State.variables (which might be out-of-date if the
 * value was changed in another tab).
 *
 * If you want more than a few authoritative values at a time,
 * use `MT.mdEntries` or `MT.mdRecord`.
 */
MT.mdGetUncached = (key) => {
  warnUnknownKey(key);
  return State.metadata.get(key);
};

/**
 * Sets metadata `key` to `value`. Any false-y value will delete the key.
 *
 * Note, each call will always decompress and deserialize
 * all metadata from localStorage, then reserialize and recompress
 * back to localStorage. So this is very expensive, and SugarCube
 * doesn't give us a way to batch multiple set operations
 * (other than bypassing SugarCube and doing it ourselves.)
 * 
 * When _isTranscript, will set state but not metadata.
 */
MT.mdSet = (key, value) => {
  warnUnknownKey(key);
  if (!State.temporary.isTranscript) {
    if (value) {
      State.metadata.set(key, value);
    } else {
    State.metadata.delete(key);
    }
  }
  if (value && knownKeys[key] !== IGNORED) {
    State.variables[key] = value;
  } else {
    delete State.variables[key];
  }
};

/** Returns an array of all [key, value] metadata entries. */
MT.mdEntries = () => {
  return State.metadata.entries() || [];
};

/** Returns an object-map of all metadata keys and values. */
MT.mdRecord = () => {
  return Object.fromEntries(MT.mdEntries());
};

/** Deletes all metadata, except for IGNORED keys. */
MT.mdClear = () => {
  const preserve = [];
  const entries = State.metadata.entries() || [];
  for (const [key, value] of entries) {
    warnUnknownKey(key);
    if (knownKeys[key] === IGNORED) {
      preserve.push([key, value]);
    }
  }
  State.metadata.clear();
  for (const [key, value] of preserve) {
    State.metadata.set(key, value);
  }
  copyToVars();
};

/** Merges metadata from `save` into current metadata. */
function readFromSave(save) {
  if (!save.metadata) return;
  const current = MT.mdRecord();
  let unlocks = false;
  for (const [key, value] of Object.entries(save.metadata)) {
    if (value && knownKeys[key] === SAVED && !current[key]) {
      State.metadata.set(key, value);
      unlocks = true;
    }
  }
  copyToVars();
  if (unlocks) {
    $(document).one(":passagestart", () => {
      MT.diag("Note: The Archives have unlocked some more entries.");
    })
  }
}

/** Adds current metadata to `save`. */
function writeToSave(save) {
  save.metadata ||= {};
  const entries = State.metadata.entries() || [];
  for (const [key, value] of entries) {
    if (knownKeys[key] === SAVED) {
      save.metadata[key] = value;
    }
  }
}

/** Copies current metadata to State.variables */
function copyToVars() {
  const U = MT.untracedVars ? MT.untracedVars() : State.variables;
  const rec = MT.mdRecord();
  for (const key of Object.keys(rec)) {
    if (knownKeys[key] !== IGNORED) {
      U[key] = rec[key];
    }
  }
  // delete unset known keys
  for (const key of Object.keys(knownKeys)) {
    if (U[key] && (!rec[key] || knownKeys[key] === IGNORED)) {
      delete U[key];
    }
  }
};

function mdInit() {
  Save.onLoad.add(readFromSave);
  Save.onSave.add(writeToSave);
  $(document).on(":passageinit", copyToVars);
}

mdInit();
<</script>>
