:: g0init Roaming [inclusion] {"position":"575,700","size":"100,100"}
<<append head>><style>
  #random-walk {
    top: max(5rem, 50vh - 5rem);
    display: flex;
    flex-direction: column;
    font-size: 18px;
    gap: 20px;
    position: fixed;
    right: 4px;
    z-index: 60;
  }

  #random-walk a {
    background-color: #fff;
    border: 1px solid transparent;
    border-radius: 4px;
    color: #000;
    cursor: pointer;
    opacity: 0.1;
    padding: 2px 4px;
    text-align: center;
    user-select: none;
  }

  #random-walk a:hover {
    background-color: #333;
    border-color: #eee;
    color: #eee;
    opacity: 1;
  }

  #random-walk.at-menu #rw-roam,
  #random-walk.at-menu #rw-forw {
    background-color: #fff;
    border-color: transparent;
    color: #000;
    cursor: not-allowed;
    opacity: 0.1;
  }

  .random-walk-chosen {
    outline: 1px solid #9cc;
  }

  #rw-roam.rw-roaming {
    background-color: #161;
    color: #7f7;
    opacity: 1;
  }
  #rw-roam.rw-roaming:hover {
    background-color: #191;
    color: #111;
  }
</style><</append>>

<<script>>

const milestones = new Set([
  "n1p Barbs Fast 1",
  "n1p Barbs Slow 1",
  "n1p Barbs Slow 2a1",
  "n1p Barbs Slow 2n1",
  "n1p Barbs Slow 2s1",
  "n1p Barbs Skip",
  "n1s Cast Alone 1",
  "n1s Cast Endgame 1",
  "n1s Cast Horny 1",
  "n1s Cast Itch 2",
  "n1s Cast Sight 1",
  "n1s Cast Sight Horny",
  "n1s Cast Younger 1",
  "n1s Guess Password",
  "n1s Impatient",
  "n1s Say Device 1",
  "n1s Say Lance",
  "n1s Say Password",
  "n1s Tap 1",
  "n1s Zero Bound",
]);

const visited = new Set();
let lastPick = {};

let ignoreFuture = false;

MT.roaming = false;

MT.forgetWalkHistory = () => {
  visited.clear();
  lastPick = {};
};

/** Random walk */
function initRandomWalk() {
  if (!setup.playtest) return;

  const idOf = el => {
    const title = $(el).attr("data-passage");
    const code = $(el).attr("data-mta-code");
    return `${title}/${code}`;
  };

  function updateLabel() {
    const isMenu = tags().includes("is-menu");
    $("#random-walk").toggleClass("at-menu", isMenu);

    const noFuture = () => {
      if (isMenu) return false;
      if (ignoreFuture) return true;
      if (State.length === State.size) return true;
      const next = State.history[State.length].title;
      const links = $("#passages a[data-passage]")
        .filter((i, el) => $(el).attr("data-passage") === next);
      return links.length === 0;
    };

    const el = $("#rw-forw");
    el.text(noFuture() ? "rand" : "next");
  }

  const goRandom = (isManual) => {
    const V = State.variables;

    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      ignoreFuture = false;
      chosen.click();
      return true;
    }
    chosen.removeClass("random-walk-chosen");

    const here = State.passage;
    const all = $("#passages a[data-passage]");
    if (all.length === 0) return false;

    let avail = all;

    // bias toward climbing the ladder of magic.
    let important = "[data-mta-code*='//prefer']";
    switch (V.n_magicPhase) {
      case MP_beforeCast:
        important += ", [data-passage*=Cast]:not([data-passage*=Itch])";
        break;
      case MP_triedMagic:
        if (!V.n_mageSight) {
          important += ", [data-passage*=Sight]";
        } else {
          important += ", [data-passage*=Mirror], [data-passage*=Tap]";
        }
        break;
      case MP_wantDevice:
        important += ", [data-passage*=Say]";
        break;
      case MP_wantName:
        important += ", [data-passage*=Say], [data-passage*=Ask]";
        important += ", [data-passage*=Bottle]";
        break;
      case MP_wantTouch:
        important += ", [data-passage*=Ask], [data-passage*=Penguin]";
        break;
      case MP_wantPass:
        important += ", [data-passage*=Password], [data-passage*=Ask]";
        break;
    }
    const prefer = all.filter(important);
    if (!isManual && prefer.length && Math.random() < .7) {
      const names = prefer.map((i, el) => $(el).attr("data-passage"));
      console.log(`prefer [${[...names].join(",")}]`);
      avail = prefer;
    } else {
      avail = avail.filter((i, el) => !visited.has(idOf(el)));
    }
    if (isManual) {
      // avoid the glitch link
      avail = avail.filter(
        (i, el) => el.dataset["passage"] !== "n1p Barbs Glitch 1"
          || Math.random() < .1
      );
    }

    // Usually try to avoid already-seen
    const seen = $(".mt-seen-true a[data-passage]");
    if (seen.length && Math.random() > .8) {
      avail = avail.filter((i, el) => !seen.is(el));
    }

    let pick = null;
    while (pick == null) {
      if (avail.length === 0) {
        all.each((i, el) => visited.delete(idOf(el)));
        avail = all;
        if (avail.length > 1) {
          // avoid picking the link we just picked
          avail = avail.filter((i, el) => idOf(el) !== lastPick[here]);
          if (avail.length === 0) avail = all;
        }
      }

      const i = Math.floor(avail.length * Math.random());
      pick = avail[i];
      const code = $(pick).attr("data-mta-code");
      const avoid = code != null && code.includes("//avoid");
      if (!isManual && avoid && Math.random() < .9) {
        const title = $(pick).attr("data-passage");
        console.log(`avoiding ${title}`);
        pick = null;
        avail.splice(i, 1);
      }
    }
    $(pick).addClass("random-walk-chosen");
    pick.scrollIntoView(false);
    lastPick[here] = idOf(pick);
    visited.add(lastPick[here]);
    return true;
  };

  const goBack = () => {
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length > 0) {
      ignoreFuture = true;
      chosen.removeClass("random-walk-chosen");
      updateLabel();
    } else {
      ignoreFuture = false;
      Engine.backward();
    }
  };

  const goForward = () => {
    if (tags().includes("is-menu")) return;
    if (State.length === State.size || ignoreFuture) {
      goRandom(true);
      return;
    }
    ignoreFuture = false;

    const next = State.history[State.length].title;
    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      if (chosen.attr("data-passage") === next) {
        Engine.forward();
      } else {
        goRandom(true);
      }
      return;
    }
    chosen.removeClass("random-walk-chosen");
    const links = $("#passages a[data-passage]")
      .filter((i, el) => $(el).attr("data-passage") === next);
    if (links.length === 1) {
      links.addClass("random-walk-chosen");
      links[0].scrollIntoView(false);
    } else {
      goRandom(true);
    }
  };

  let roamDoneFn = null;
  let roamForce = false;
  let roamLoop = 0;
  let roamPath = null;

  const roamDelay = 50;
  const maxLoop = 5;

  const roamToggle = () => {
    if (tags().includes("is-menu")) return;
    if (MT.roaming) {
      roamStop();
    } else {
      roamStart();
    }
  };

  function hasTodo() {
    return MT.isDraft(State.passage) ||
      /\bX[X]X\b|\bTO[D]O\b/.test($(".passage").text());
  }

  const startLoop = () => {
    console.log("# starting new loop");
    MT.forgetWalkHistory();
    State.reset();
    State.variables.g_versionAtStart = setup.version;
    Engine.play("g1a Bound");
    roamForce = false;
    const neroStart = [
      { t: "g1a Choose Character" },
      { t: "n1a Nero Start" },
    ];
    MT.roamStart(neroStart, () => {
      MT.roamStart(null, () => {
        roamLoop--;
        if (roamLoop > 0) startLoop();
      });
    });
  };

  const roamStart = MT.roamStart = (path, doneFn, force) => {
    roamPath = path;
    roamDoneFn = doneFn;
    roamForce = force;

    $("#rw-roam").addClass("rw-roaming");
    MT.roaming = true;

    /* If starting from an ending, start looping. */
    if (path == null && tags().includes("roam-stop")) {
      roamLoop = maxLoop;
      return startLoop();
    }

    /* If starting from draft or todo, continue past todo */
    if (path == null && hasTodo()) {
      roamForce = true;
    }

    setTimeout(roamNext, roamDelay);
  };

  const roamStop = () => {
    MT.roaming = false;
    roamDoneFn = null;
    roamPath = null;
    $("#rw-roam").removeClass("rw-roaming");
  };

  const reportEnd = reason => {
    const V = State.variables;
    console.log(`${reason} after ${State.turns} steps at ${State.passage}`);
    console.log(`- local + session storage = ${MT.computeSizes()}`);
    const mp = MT.enumSymbol('MagicPhase', V.n_magicPhase);
    const mpr = MT.enumSymbol('MagicPhase', V.n_magicPhaseReached);
    console.log(`- magicPhase ${mp}, ${mpr}`);
  };

  const roamNext = () => {
    if (!MT.roaming) return roamStop();

    const chosen = $("#passages .random-walk-chosen");
    if (chosen.length === 1) {
      chosen[0].click();
      setTimeout(roamNext, roamDelay);
      return;
    }

    /* show milestone */
    const here = State.passage;
    if (milestones.has(here)) {
      console.log(`milestone ${here}`);
    }

    /* stop on problem */
    if (MT.hasFails || MT.hasWarnings || $(".error-view").length) {
      console.log('stopping on problem');
      return roamStop();
    }

    /* stop on to-do (if not forced) */
    if (!roamForce && hasTodo()) {
      console.log('stopping on to-do');
      return roamStop();
    }

    /* skip comments in path */
    if (roamPath != null) {
      while (roamPath.length && roamPath[0].t == null) {
        roamPath.shift();
      }
    }

    /* at end of path */
    if (roamPath != null && roamPath.length === 0) {
      if (roamDoneFn != null) setTimeout(roamDoneFn);
      reportEnd("path end");
      return roamStop();
    }

    /* follow path */
    if (roamPath != null) {
      const next = roamPath[0];
      const links = $("#story a[data-passage]");
      const isStep = (el, step) => {
        const title = el.getAttribute("data-passage");
        const code = el.getAttribute("data-mta-code") || null;
        return title === step.t &&
          (code == null || step.code == null || code === step.code);
      };
      for (const link of links) {
        if (isStep(link, next)) {
          roamPath.shift();
          $(link).addClass("random-walk-chosen");
          setTimeout(roamNext, 100);
          return;
        }
      }
      MT.warn(`Broken path: ${JSON.stringify(next)}`);
      return roamStop();
    }

    /* stop at stop passage */
    if (tags().includes("roam-stop")) {
      reportEnd("roam-stop");
      if (roamDoneFn != null) setTimeout(roamDoneFn);
      return roamStop();
    }

    /* pick a random link */
    if (goRandom(false)) {
      setTimeout(roamNext, roamDelay);
      return;
    }
    
    roamStop();
  };

  $(() => {
    $("#random-walk").remove();
    const outer = $("<div>")
      .attr("id", "random-walk")
      .appendTo("#story");
    $("<a>")
      .attr("title", "<ctrl-comma> backward")
      .text("back")
      .click(goBack)
      .appendTo(outer);
    if (setup.debug) {
      $("<a id=rw-roam>")
        .toggleClass("rw-roaming", MT.roaming)
        .text("roam")
        .click(roamToggle)
        .appendTo(outer);
    }
    $("<a id=rw-forw>")
      .attr("title", "<ctrl-period> forward or random")
      .text("forw")
      .click(goForward)
      .appendTo(outer);
    updateLabel();
  });

  // ctrl-comma doesn't generate keypress events
  $(document).on("keydown", ev => {
    if (!ev.ctrlKey) return;
    const focus = document.activeElement;
    const tag = focus != null ? focus.tagName : "";
    if (/^(textarea|input|select)$/i.test(tag)) return;
    if (ev.key === ",") return goBack();
    if (ev.key === ".") return goForward();
  });

  $(document).on("click", ev => {
    if (!MT.roaming && ev.target && ev.target.tagName !== "A") {
      const chosen = $("#passages .random-walk-chosen");
      if (chosen.length) {
        chosen.removeClass("random-walk-chosen");
        ignoreFuture = true;
        updateLabel();
      }
    }
  });

  $(document).on(":passagedisplay", () => {
    updateLabel();
  });
}

initRandomWalk();
<</script>>
